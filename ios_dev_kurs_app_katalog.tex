\documentclass[parskip=half, final]{scrreprt}

\input{include/variables}
\input{include/style}
\input{include/code_listing}

\renewcommand{\doctype}{App Katalog}
\renewcommand{\shortdoctype}{App Katalog}

\begin{document}

\maketitle

\tableofcontents


\chapter{Über dieses Dokument}

Dieser App Katalog enthält Schritt-für-Schritt Anleitungen für die im Rahmen unseres Kurses erstellten Apps sowie die wöchentlich zu bearbeitenden Übungsaufgaben und wird im Verlauf des Semesters kapitelweise auf der Vorlesungswebseite \linkref{http://ios-dev-kurs.github.io/} zur Verfügung gestellt.

Er dient jedoch nur als Ergänzung zum parallel verfügbaren \strong{Skript}, auf das hier häufig verwiesen wird. Dort sind die Erläuterungen zu den verwendeten Technologien, Methoden und Begriffen zu finden.


\begin{lecture} % Lecture 1


\chapter{Hello World}

Was ist schon ein Programmierkurs, der nicht mit einem klassischen \emph{Hello World} Programm beginnt? Wir werden jedoch noch einen Schritt weitergehen und diesen Gruß vom iOS Simulator oder, soweit vorhanden, direkt von unseren eigenen iOS Geräten ausgeben lassen. Außerdem wird in die objektorientierte Programmierung in \emph{Swift} eingeführt.

\skriptref{Xcode, Programmieren in Swift} sowie das Buch \emph{The Swift Programming Language} \linkref{https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/}


\section{Grundlagen der Programmierung in Swift}

Anhand des ersten Kapitels \emph{A Swift Tour} des Buches \emph{The Swift Programming Language} lernen wir zunächst die Grundlagen der Programmierung in Swift kennen.

\begin{enumerate}

\item Öffnet Xcode und erstellt zunächst einen \emph{Playground} mit \keys{\cmd + \shift + \Alt + N}. Playgrounds sind interaktive Skripte, mit denen sich ideal Code ausprobieren lässt. Gebt der Datei einen Namen wie \str{01 - Grundlagen der Programmierung in Swift} und speichert sie in einem Verzeichnis für diesen Kurs.
\item Ein Playground besteht aus einem Editor- und einem Inspektorbereich und führt geschriebenen Code automatisch aus. Ausgaben und Laufzeitinformationen werden im Inspektor angezeigt. In nur einer Zeile Code können wir den traditionellen \emph{Hello World!}-Gruß ausgeben lassen \abbref{img:playground_helloworld}.

\begin{swiftcode}
println("Hello World!")	
\end{swiftcode}
	
\item Nun lernen wir anhand des ersten Kapitels \emph{A Swift Tour} des Buches \emph{The Swift Programming Language} zunächst die Grundlagen der Programmierung in Swift.
	
	Auf der Vorlesungswebseite findet ihr den Playground aus der Vorlesung, der in diese Konzepte einführt. Macht euch dabei mit folgenden Begriffen vertraut:

	\begin{itemize}
		\item Variablen (\swiftinline{var}) und Konstanten(\swiftinline{let})
		\item Einfache Datentypen (\swiftinline{Int}, \swiftinline{Float}, \swiftinline{Double}, \swiftinline{Bool}, \swiftinline{String}, \swiftinline{Array}, \swiftinline{Dictionary} und \swiftinline{Set})
		\item Type Inference
		\item String-Formatierung
		\item Einfache Operatoren (\swiftinline{+}, \swiftinline{-}, \swiftinline{*}, \swiftinline{/}, \swiftinline{\%})
		\item Abfragen (\swiftinline{if}, \swiftinline{switch}) und Schleifen (\swiftinline{for}, \swiftinline{while})
		\item Optionals
		\item Funktionen
	\end{itemize}
	
	Im zweiten Kapitel \emph{Language Guide} in \emph{The Swift Programming Language} werden diese Konzepte noch einmal detailliert erklärt. Informiert euch dort gerne genauer darüber. Zunächst genügt es jedoch, einen Überblick zu erhalten. Im Verlauf des Kurses werden wir noch viel Übung im Umgang mit diesen Konzepten bekommen.
	
\includegraphicsc[\screenshotwidth]{img/playground_helloworld.png}{img:playground_helloworld}{Playgrounds eignen sich ideal zum Ausprobieren von Swift Code.}

\end{enumerate}

\begin{exc}

\begin{excitem}{fibonacci}{Fibonacci}{1}

\begin{enumerate}
\item Schreibt einen Algorithmus, der alle Folgenglieder $F_n < 1000$ der Fibonaccifolge
\begin{equation}
F_n = F_{n-1} + F_{n-2}
\end{equation}
\begin{equation}
F_1=1, F_2=2
\end{equation}
in der Konsole ausgibt.
\item \excextra{Bei jeder geraden Fibonaccizahl $F_j$ ist der Abstand $\Delta n=j-i$ zum vorherigen geraden Folgenglied $F_i$ auszugeben.}
\end{enumerate}

\end{excitem}

\begin{excitem}{primenumbers}{Primzahlen}{2}


\begin{enumerate}

\item Schreibt eine Funktion \swiftinline{primeNumbersUpTo:}, die ein Argument \swiftinline{maxNumber: Int} annimmt und alle Primzahlen bis \swiftinline{maxNumber} als Liste \swiftinline{[Int]} zurückgibt.

\exchinweis{Mit dem Modulo-Operator \swiftinline{|\%|} kann der Rest der Division zweier Integer gefunden werden:}

\begin{swiftcode}
let a = 20%3 // a ist jetzt Int(2)
\end{swiftcode}

\item \emph{Optionals} sind eines der elegantesten Konzepte in Swift, und sind auch in anderen modernen Sprachen zu finden. Informiert euch darüber im Kapitel \emph{Language Guide > The Basics > Optionals} in \emph{The Swift Programming Language}. Dieses Kapitel (bis einschließlich \emph{Implicitly Unwrapped Optionals}) ist sehr wichtig, da wir in der iOS App Programmierung häufig mit Optionals arbeiten werden!

\item Verwendet eure Liste von Primzahlen aus der vorigen Aufgabe, um effizienter zu prüfen, ob eine Zahl eine Primzahl ist.

Schreibt dazu eine Funktion \swiftinline{isPrimeNumber:cachedPrimeNumbers:}, die eine Zahl \swiftinline{n: Int} und eine \strong{optionale} Liste von Primzahlen \swiftinline{cachedPrimeNumbers: [Int]?} annimmt. Verwendet die \emph{Optional Binding} Syntax \swiftinline{if let} um mit dieser Liste zu arbeiten, wenn eine solche übergeben wurde und lang genug ist. Dann genügt es zu prüfen, ob die Zahl in der Liste enthalten ist. Wenn kein Liste übergeben wurde, soll die Primzahl wie in a) manuell geprüft werden.

\begin{exchinweise}

\item Dem Argument \swiftinline{cachedPrimeNumbers} können wir einen \emph{default} Wert \swiftinline{nil} zuweisen:

\begin{swiftcode}
func isPrimeNumber(n: Int, cachedPrimeNumbers: [Int]? = nil) -> Bool {
    // ...
}	
\end{swiftcode}

So kann die Funktion auch ohne dieses Argument aufgerufen werden:

\begin{swiftcode}
isPrimeNumber(7, cachedPrimeNumbers: [ 1, 2, 3, 7 ]) // vollständiger Funktionsaufruf, verwendet übergebene Liste zum Nachschlagen
isPrimeNumber(7) // äquivalent zu:
isPrimeNumber(7, cachedPrimeNumbers: nil) // Prüft Primzahl manuell
\end{swiftcode}

\item Die globale Funktion \swiftinline{contains} prüft ob eine Element in einer Liste enthalten ist:

\begin{swiftcode}
contains([ 1, 2, 3, 7 ], 7) // true
\end{swiftcode}

\item Testet eure Funktion, indem Ihr bspw. folgenden Code ans Ende des Storyboards setzt:

\begin{swiftcode}
//: ## Testing

let n = 499 // Number to test
let cachedMax = 500 // Prime numbers up to this number will be cached
import Foundation
var startDate: NSDate

startDate = NSDate()
let cachedPrimeNumbers = primeNumbersUpTo(cachedMax)
println("Time for caching prime numbers up to \(cachedMax): \(-startDate.timeIntervalSinceNow)s")

startDate = NSDate()
if isPrimeNumber(n) {
    println("\(n) is a prime number.")
} else {
    println("\(n) is not a prime number.")
}
let withoutCacheTime = -startDate.timeIntervalSinceNow
println("Time without cache: \(withoutCacheTime)s")

startDate = NSDate()
isPrimeNumber(n, cachedPrimeNumbers: cachedPrimeNumbers)
let withCacheTime = -startDate.timeIntervalSinceNow
println("Time with cache: \(withCacheTime)s (\((1 - withCacheTime / withoutCacheTime) * 100)% faster)")
\end{swiftcode}

\end{exchinweise}

\end{enumerate}

\end{excitem}

\end{exc}


\end{lecture}


\begin{lecture} % Lecture 2


\section{Objektorientiertes "{}Hello World!"{}}

\begin{enumerate}

\item Nun versuchen wir uns an der objektorientierten Programmierung und möchten den \objcinline{Hello World!} Gruß von virtuellen Repräsentationen einzelner Personen ausgeben lassen. Erstellt dazu einen Xcode Playground bspw. mit Titel \str{02 - Objektorientierte Programmierung in Swift}.

\item Verschafft euch anhand \emph{The Swift Programming Language} und dem Playground aus der Vorlesung (auf der Vorlesungswebseite) einen Überblick über folgende Konzepte der objektorientierten Programmierung in Swift:

\begin{itemize}
	\item Klassen und Objekte
	\item Attribute mit oder ohne Startwert
	\item Initializer
	\item Instanz- und Klassenmethoden
	\item Subklassen und Überschreiben von Methoden
	\item Structs und Enums
\end{itemize}

\end{enumerate}

\begin{exc}

\begin{excitem}{scientists}{Scientists}{1}

\begin{enumerate}
\item Erstellt (am besten in einem neuen Playground, in den ihr die Klasse \swiftinline{Person} aus der Vorlesung einfügt) eine weitere Klasse \swiftinline{Scientist} als \emph{Subklasse} von \swiftinline{Person}.

Wissenschaftler können rechnen, fügt dieser Klasse also eine Methode \swiftinline{sayPrimeNumbersUpTo:} hinzu, die ein Argument \swiftinline{maxNumber: Int} annimmt und alle Primzahlen bis zu dieser Zahl in der Konsole ausgibt. Verwendet dazu den Algorithmus aus der vorherigen Übungsaufgabe \excref{exc:primenumbers}.

\begin{hinweis}
Wie in \emph{The Swift Programming Language} beschrieben, erbt eine Subklasse die Attribute und Methoden ihrer Superklasse und kann diese überschreiben:
\begin{swiftcode}
class Scientist: Person {
    ...
}	
\end{swiftcode}
\end{hinweis}

\item Wir wollen uns vergewissern, dass die Klasse \swiftinline{Scientist} die Attribute und Methoden ihrer Superklasse \swiftinline{Person} erbt. Erstellt ein \swiftinline{Scientist}-Objekt, gebt ihm einen Namen und lasst den \swiftinline{Hello World}-Gruß ausgeben.
\item Nach dem Prinzip des \emph{Überschreiben} soll ein Wissenschaftler einen anderen Gruß ausgeben als eine "{}normale"{} Person. Überschreibt in der \swiftinline{Scientist}-Klasse die Methode \swiftinline{sayHello}, sodass zusätzlich \str{Ask me for prime numbers!} ausgegeben wird.
\end{enumerate}

\end{excitem}

\begin{excitem}{emails}{Poker}{3}

In dieser Aufgabe berechnen wir die Wahrscheinlichkeit für einen \emph{Flush} beim Poker.

\begin{enumerate}

\item Zunächst modellieren wir die Spielkarten. Eine Karte hat immer eine \emph{Farbe/Suit} (\emph{Karo/Diamonds}, \emph{Herz/Hearts}, \emph{Pik/Spades} oder \emph{Kreuz/Clubs}) und einen \emph{Rang/Rank} (\emph{2} bis \emph{10}, \emph{Bube/Jack}, \emph{Dame/Queen}, \emph{König/King} oder \emph{Ass/Ace}).

	Schreibt zwei Enums \swiftinline{enum Suit: Int} und \swiftinline{enum Rank: Int} mit ihren entsprechenden Fällen (\swiftinline{case Diamonds} usw.). Bei den Rängen \emph{2} bis \emph{10} schreibt ihr am besten die Zahl aus. Implementiert jeweils eine \emph{Computed Property} \swiftinline{var symbol: String}, in der ihr mithilfe einer \swiftinline{switch}-Abfrage für jeden Fall ein Symbol zurückgebt. \strong{Tipp:} Für die Farben gibt es Unicode-Symbole\linkref{http://en.wikipedia.org/wiki/Playing_cards_in_Unicode}!
	
	Schreibt dann einen \swiftinline{struct Card} mit zwei Attributen \swiftinline{let suit: Suit} und \swiftinline{let rank: Rank}, sowie einer \emph{Computed Property} \swiftinline{var description: String}, die einen aus Farbe und Rang zusammengesetzten String zurückgibt.
		
\item Nun können wir eine Poker Hand modellieren. Schreibt den \swiftinline{struct PokerHand} mit einem Attribut \swiftinline{let cards: [Card]} und einer \emph{Computed Property} \swiftinline{var description: String}, die die \swiftinline{description} der Karten kombiniert.

	Um einfach zufällige Poker Hände generieren zu können, implementiert einen Initializer \swiftinline{init()}, der eine Hand aus fünf zufälligen Karten erstellt. \strong{Wichtig:} Da aus einem Deck von paarweise verschiedenen Karten gezogen wird, darf keine Karte doppelt vorkommen.
	
	\begin{exchinweise}
		\item Da wir \swiftinline{Suit} und \swiftinline{Rank} von \swiftinline{Int} abgeleitet haben, können wir Zufallszahlen generieren und die Enums daraus erstellen:
	
		\begin{swiftcode}
        let rndSuit = Suit(rawValue: Int(arc4random_uniform(4)))!
        let rndRank = Rank(rawValue: Int(arc4random_uniform(13)))!
        let rndCard = Card(suit: rndSuit, rank: rndRank) // Eine zufällige Spielkarte
		\end{swiftcode}
		
		\item Die Funktion \swiftinline{contains} könnte hilfreich sein, um das Vorhandensein von Karten zu überprüfen. Um diese mit \swiftinline{Card} verwenden zu können, müsst ihr erst eine Äquivalenzrelation implementieren: Schreibt \swiftinline{struct Card: Equatable { ... }} und dann außerhalb des Struct:
		
		\begin{swiftcode}
        func ==(lhs: Card, rhs: Card) -> Bool {
            return lhs.suit == rhs.suit && lhs.rank == rhs.rank
        }
		\end{swiftcode}
	\end{exchinweise}
	
\item Erstellt ein paar Poker Hände und lasst euch die \swiftinline{description} ausgeben. Habt ihr etwas gutes gezogen?

	Implementiert nun ein weiteres Enum \swiftinline{enum Ranking: Int} mit den Fällen \swiftinline{case HighCard, Flush, StraightFlush} usw., die ihr bspw. auf Wikipedia\linkref{http://en.wikipedia.org/wiki/List_of_poker_hands} findet.

	Fügt dann dem \swiftinline{struct PokerHand} eine Computed Property \swiftinline{var ranking: Ranking} hinzu. Implementiert hier einen Algorithmus, der prüft, ob ein \emph{Flush} vorliegt. Dann soll \swiftinline{.Flush} zurückgegeben werden, ansonsten einfach \swiftinline{.HighCard}.
	
\item Wir können nun einige tausend Hände generieren und die Wahrscheinlichkeit für einen Flush abschätzen. Fügt einfach folgenden Code am Ende des Playgrounds ein:

\begin{swiftcode}
var rankingCounts = [Ranking : Int]()
let samples = 1000
for var i=0; i<samples; i++ {
    let ranking = PokerHand().ranking
    if rankingCounts[ranking] == nil {
        rankingCounts[ranking] = 1
    } else {
        rankingCounts[ranking]!++
    }
}
for (ranking, count) in rankingCounts {
    println("The probability of being dealt a \(ranking.description) is \(Double(count) / Double(samples) * 100)%")
}	
\end{swiftcode}

	Die Ausführung kann etwas dauern, justiert ggfs. \swiftinline{samples}. Stimmt die Wahrscheinlichkeit etwa mit der Angabe auf Wikipedia überein?

\item \strong{Extra:} Ihr könnt das Programm nun noch erweitern und versuchen, die anderen Ränge zu überprüfen. Dabei könnten Hilfsattribute wie \swiftinline{var hasFlush: Bool} oder \swiftinline{var pairCount: Int} nützlich sein. Bekommt es jemand es jemand hin, eine Funktion zu schreiben, die zwei Hände vergleicht und den Sieger bestimmt? \strong{Tipp:} Dazu könnte es hilfreich sein, die Fälle des \swiftinline{enum: Ranking} um \emph{Associated Attributes} zu erweitern.

\end{enumerate}

\end{excitem}

\end{exc}


\end{lecture}


\begin{lecture} % Lecture 3


\section{Das erste Xcode Projekt}

iOS Apps schreiben wir natürlich nicht in Playgrounds. Eine App besteht aus vielen Komponenten wie Klassen, Interface-Dateien und weiteren Ressourcen, die wir in einem Xcode Projekt zusammenfassen.

\skriptref{Xcode}

\begin{enumerate}

\item Um nun unsere erste iOS App zu erstellen, rufen wir mit \keys{\cmd + \shift + N} zunächst den Dialog zur Erstellung eines neuen Projekts auf und wählen das Template \menu{iOS > Application > Single View Application}.

\item Tragt im erscheinenden Konfigurationsdialog entsprechend der Konventionen den Product Name \str{HelloWorld}, euren Vor- und Nachnamen als Organization Name und \str{de.uni-hd.<deinname>} als Company Identifier ein \abbref{img:helloworld_xcproj}. Das führt zu der Bundle ID \str{de.uni-hd.<deinname>.HelloWorld}. Wählt \emph{Swift}, \emph{Universal} und entfernt die Auswahl von \emph{Use Core Data}. Speichert das Projekt in einem Verzeichnis eurer Wahl.

\includegraphicsc[\screenshotwidth]{img/helloworld_xcproj.png}{img:helloworld_xcproj}{Damit es keine Konflikte zwischen verschiedenen Apps gibt, gibt es Konventionen bei der Konfiguration}

\item Wir sehen nun Xcodes Benutzeroberfläche und können sie mit den Schaltflächen rechts in der Toolbar anpassen. Verwendet zunächst die Konfiguration mit eingeblendetem Navigator, verstecktem Debug-Bereich und Inspektor und Standard-Editor. Wählt im Project Navigator das Projekt selbst aus \abbref{img:helloworld_targetconfig}.

\includegraphicsc[\screenshotwidth]{img/helloworld_targetconfig.png}{img:helloworld_targetconfig}{Wird das Projekt ausgewählt, sehen wir im Editor die Projekt- und Targetkonfiguration.}

\item Im Editor wird die \emph{Projekt- und Targetkonfiguration} angezeigt. Hier können wir bspw. die Bundle ID unserer App anpassen, die wir zuvor bei der Erstellung des Projekts aus Product Name und Company Identifier zusammengesetzt haben.

\item Links in der Toolbar sind die Steuerelemente des Compilers zu finden. Wählt das gerade erstellte Target und ein Zielsystem aus, bspw. den \emph{iPhone 6} Simulator, und klickt die \emph{Build \& Run} Schaltfläche. Das Target wird nun kompiliert und generiert ein \emph{Product}, also unserer App, die im Simulator ausgeführt wird. In Xcode kann mit \keys{\cmd + .} die Ausführung gestoppt und mit \keys{\cmd + R} (Tastenkürzel für \emph{Build \& Run}) erneut gestartet werden.

\end{enumerate}


\section{"{}Hello World!"{} on Simulator}

\begin{enumerate}

\item Besonders spannend ist diese App natürlich noch nicht. Das ändern wir jetzt spektakulär, indem wir eine Ausgabe hinzufügen. Wählt die Datei \emph{AppDelegate.swift} im Project Navigator aus.

\item Die Methode \swiftinline{application:didFinishLaunchingWithOptions:} wird zu Beginn der Ausführung der App aufgerufen. Ersetzt den Kommentar dort mit dem bekannten Gruß zur Ausgabe in der Konsole:

\begin{swiftcode}
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
    println("Hello World!")
    return true
}
\end{swiftcode}

\item Wenn wir unsere App nun erneut mit \emph{Build \& Run} kompilieren und ausführen, sehen wir den Text \str{Hello World!} in der Konsole. Dazu wird der zweigeteilte Debug-Bereich unten automatisch eingeblendet \abbref{img:helloworld_helloworld}. Ist der Konsolenbereich zunächst versteckt, kann er mit der Schaltfläche in der rechten unteren Ecke angezeigt werden. Außerdem wird links automatisch zum Debug Navigator gewechselt, wenn eine App ausgeführt wird, in dem CPU- und Speicherauslastung überwacht werden können und Fehler und Warnungen angezeigt werden, wenn welche auftreten.

\includegraphicsc[\screenshotwidth]{img/helloworld_helloworld.png}{img:helloworld_helloworld}{In der Konsole des Debug-Bereichs werden Ausgaben der laufenden App angezeigt}

\end{enumerate}


\section{"Hello World!"{} on Device}

\begin{enumerate}

\item Nun möchten wir unsere neue App natürlich auch auf einem realen iOS Gerät anstatt des Simulators testen. Im Skript findet ihr eine Anleitung, wie ihr mit euren iOS Geräten unserem Developer Team der Uni Heidelberg beitreten könnt.

\item Habt ihr die Schritte befolgt und euren freigeschalteten Apple Developer Account in den Xcode-Accounteinstellungen hinzugefügt, öffnet ihr wieder die Projekt- und Targetkonfiguration im Project Navigator und wählt dort unser Developer Team \abbref{img:helloworld_chooseteam} aus. Nun wird automatisch das richtige Provisioning Profile für die Bundle ID des Targets verwendet.

\includegraphicsc[\screenshotwidth]{img/helloworld_chooseteam.png}{img:helloworld_chooseteam}{Mit der Wahl des zugehörigen Developer Teams in der Project- und Targetkonfiguration verwendet Xcode automatisch das passende Provisioning Profile}

\item Verbindet euer iOS Gerät mit eurem Mac und wählt es in der Toolbar als Zielsystem aus. Mit einem \emph{Build \& Run} wird die App nun kompiliert, auf dem Gerät installiert und ausgeführt. In der Konsole erscheint wieder die Ausgabe \str{Hello World!}, diesmal direkt vom Gerät ausgegeben.

\end{enumerate}


\section{Graphisches "{}Hello World!"{}}

Natürlich wird ein Benutzer unserer App von den Ausgaben in der Konsole nichts mitbekommen. Diese dienen bei der Programmierung hauptsächlich dazu, Abläufe im Code nachzuvollziehen und Fehler zu finden. Unsere App ist also nur sinnvoll, wenn wir die Ausgaben auch auf dem Bildschirm darstellen können.

\skriptref{Xcode}

\begin{enumerate}

\item Zur Gestaltung der Benutzeroberfläche oder \emph{User Interface (UI)} verwenden wir den in Xcode integrierten \emph{Interface Builder (IB)}. Wir haben bei der Projekterstellung der ersten App das \emph{Single View}-Template ausgewählt, daher enthält das Projekt bereits ein \emph{Storyboard}. Öffnet das Projekt und wählt im Navigator die Datei \emph{Main.storyboard} aus.

\item Der Editor-Bereich zeigt nun den Interface Builder. In diesem Modus möchten wir häufig eine angepasste Konfiguration des Xcode-Fensters verwenden, es bietet sich also an, mit \keys{\cmd + T} einen neuen Tab zu öffnen. Blendet dann mit den Schaltflächen in der Toolbar den Navigator- und Debug-Bereich aus und den Inspektor ein. Wählt dort außerdem zunächst den Standard-Editor \abbref{img:helloworld_ib}.

\includegraphicsc[\screenshotwidth]{img/helloworld_ib.png}{img:helloworld_ib}{Für den Interface Builder verwenden wir eine angepasste Fensterkonfiguration mit dem Inspektor anstatt des Navigators}

\item Unser UI besteht bisher nur aus einer einzigen Ansicht, oder \emph{Scene}. Ein Pfeil kennzeichnet die Scene, die zum Start der App angezeigt wird. Im Inspektor ist unten die Object Library zu finden. Wählt den entsprechenden Tab aus, wenn er noch nicht angezeigt wird \abbref{img:helloworld_ib}.

\item Durchsucht die Liste von Interfaceelementen nach einem Objekt der Klasse \swiftinline{UILabel}, indem ihr das Suchfeld unten verwendet, und zieht ein Label irgendwo auf die erste Scene. Doppelklickt auf das erstellte Label und tippt \str{Hello World!}.

\item Ein \emph{Build \& Run} mit einem iPhone-Zielsystem zeigt diesen Gruß nun statisch auf dem Bildschirm an.

\item Habt ihr das Label im Interface Builder ausgewählt, zeigt der Inspektor Informationen darüber an. Im \emph{Identity Inspector} könnt ihr euch vergewissern, dass das Objekt, was zur Laufzeit erzeugt wird und das Label darstellt, ein Objekt der Klasse \swiftinline{UILabel} ist. Im \emph{Attributes Inspector} stehen viele Optionen zur Auswahl, mit denen Eigenschaften wie Inhalt, Schrift und Farbe des Labels angepasst werden können.

\item Natürlich möchten wir unser UI zur Laufzeit mit Inhalt füllen und den Benutzer mit den Interfaceelementen interagieren lassen können. Zieht ein \swiftinline{UIButton}- und \swiftinline{UITextField}-Objekt auf die Scene und positioniert sie passend \abbref{img:helloworld_ui}. Mit dem Attributes Inspector könnt ihr dem Button nun den Titel \str{Say Hello!} geben und für das Text Field einen Placeholder \str{Name} einstellen.

\includegraphicsc[.6\textwidth]{img/helloworld_ui.png}{img:helloworld_ui}{Mit einem Text Field, einem Button und einem Label erstellen wir ein simples UI}

\item Zur Laufzeit der App wird für jedes im Storyboard konfigurierte Interfaceelement ein Objekt der entsprechenden Klasse erstellt und dessen Attribute gesetzt. Um nun im Code auf die erstellten Objekte zugreifen und auf Benutzereingaben reagieren zu können, verwenden wir \emph{IBOutlets} und \emph{IBActions}.
	
	Blendet den Inspektor aus und wählt stattdessen den Assistant-Editor in der Toolbar. Stellt den Modus in der Jump bar auf \emph{Automatic}. Im Assistant wird automatisch die Implementierung des übergeordneten View Controllers eingeblendet \abbref{img:helloworld_assistant}.

\includegraphicsc[\screenshotwidth]{img/helloworld_assistant.png}{img:helloworld_assistant}{Mithilfe des Assistants können Interface-Builder und Code nebeneinander angezeigt werden.}

\item \emph{View Controller} sind Objekte einer Subklasse von \swiftinline{UIViewController}, die jeweils einen Teil der App steuern. Diese sind zentrale Bestandteile einer App, mit denen wir uns noch detailliert beschäftigen werden. Ein erster View Controller zur Steuerung dieser ersten Ansicht wurde bereits bei der Projekterstellung automatisch hinzugefügt.

	Fügt dieser Klasse \swiftinline{ViewController: UIViewController} Attribute für das \swiftinline{UILabel} und das \swiftinline{UITextField} hinzu und kennzeichnet diese mit \swiftinline{@IBOutlet}. Implementiert außerdem eine mit \swiftinline{IBAction} gekennzeichnete Methode, die aufgerufen werden soll, wenn der Benutzer den \swiftinline{UIButton} betätigt:

\begin{swiftcode}
import UIKit

class ViewController: UIViewController {

    @IBOutlet var nameTextfield: UITextField!
    @IBOutlet var greetingLabel: UILabel!

    @IBAction func greetingButtonPressed(sender: UIButton) {
        println("Hello World!")
    }
    
}
@end
\end{swiftcode}

	Beachtet, dass IBOutlets im Allgemeinen als \emph{Implicitly Unwrapped Optionals} deklariert werden, da ihr Wert bei der Initialisierung des View Controllers zwar noch nicht existiert, anschließend jedoch unter Verwendung des Storyboards zuverlässig zugewiesen wird. So muss zwar unbedingt aufgepasst werden, dass die IBOutlet Verbindung im Storyboard hergestellt ist und nicht auf das Attribut zugegriffen wird, bevor dieses geladen wurde, doch es ist dann nicht jedes mal notwendig, das Optional zu entpacken.

\item Nun zieht mit gedrückter \keys{\ctrl}-Taste eine Linie von dem Textfeld und dem Label im Interface Builder auf das jeweilige Attribut im Code. Die Codezeile wird dabei blau hinterlegt. Zieht außerdem genauso eine Line von dem Button auf die zuvor definierte Methode. Im Connection Inspector könnt ihr die IBOutlets und IBActions eines ausgewählten Objekts betrachten und wieder entfernen. Dieser Prozess ist im Skript noch detaillierter beschrieben.

\item Versucht nun einen \emph{Build \& Run}. Betätigt ihr den Button, wird die Methode ausgeführt und der Gruß \str{Hello World!} in der Konsole ausgegeben!

\item Um die App nun alltagstauglich zu gestalten, muss dieser Gruß natürlich personalisiert und auf dem Bildschirm angezeigt werden. Dazu verwenden wir das Attribut \swiftinline{text} der Klassen \swiftinline{UITextField} und \swiftinline{UILabel}:

\begin{swiftcode}
@IBAction func greetingButtonPressed(sender: UIButton) {
    self.greetingLabel.text = "Hello \(self.nameTextfield.text)!"
}
\end{swiftcode}

	Nach einem \emph{Build \& Run} erhalten wir unser erstes interaktives Interface, in dem ihr im Textfeld einen Namen eintippen könnt und persönlich begrüßt werdet \abbref{img:helloworld_final}!

\includegraphicsc[\iphonewidth]{img/helloworld_final.png}{img:helloworld_final}{Drücken wir auf den Button, werden wir persönlich begrüßt. Sehr praktisch!}

\end{enumerate}

\begin{exc}

\begin{excitem}{simpleui}{Simple UI}{2}

Erstellt ein neues Projekt und schreibt eine App mit einigen Interfaceelementen, die etwas sinnvolles tut.

Implementiert eines der folgenden Beispiele oder eine eigene Idee. Ich freue mich auf kreative Apps!

\begin{description}
\item[Counter] Auf dem Bildschirm ist ein Label zu sehen, das den Wert eines Attributs \swiftinline{var count: Int} anzeigt, wenn eine Methode \swiftinline{updateLabel} aufgerufen wird. Buttons mit den Titeln \str{+1}, \str{-1} und \str{Reset} ändern den Wert dieses Attributs entsprechend und rufen die \swiftinline{updateLabel}-Methode auf.
\item[BMI] Nach Eingabe von Gewicht $m$ und Größe $l$ wird der Body-Mass-Index\linkref{http://de.wikipedia.org/wiki/Body-Mass-Index} $BMI=m/l^2$ berechnet und angezeigt. Als Erweiterung kann die altersabhängige Einordnung in die Gewichtskategorien angezeigt werden.
\item[RGB] In drei Textfelder kann jeweils ein Wert zwischen 0 und 255 für die Rot-, Grün- oder Blau-Komponenten eingegeben werden. Ein Button setzt die Hintergrundfarbe \swiftinline{self.view.backgroundColor} entsprechend und ein weiterer Button generiert eine zufällige Hintergrundfarbe. Ihr könnt noch einen \swiftinline{UISwitch} hinzufügen, der einen Timer ein- und ausschaltet und damit die Hintergrundfarbe bei jedem Timerintervall zufällig wechselt (s. Hinweis).
\end{description}

\begin{exchinweise}
\item Achtet darauf, dass ihr bei/nach der Projekterstellung in der Targetkonfiguration die Bundle ID \str{de.uni-hd.<deinname>.<productname>} mit \str{<productname>} z.B. \str{Counter}, \str{BMI} oder \str{RGB} eingestellt und unser Developer Team ausgewählt habt, damit die Ausführung der App auf euren eigenen Geräten funktioniert!
\item Die Klasse \swiftinline{NSString} aus Apple's \swiftinline{Foundation} Framework besitzt Instanzmethoden wie \swiftinline{floatValue} zur Umwandlung von Text in Zahlenwerte. \swiftinline{String} und \swiftinline{NSString} sind direkt ineinander überführbar:
	\begin{swiftcode}
    let s = "0.1"
    let f: Float = (s as NSString).floatValue
	\end{swiftcode}

	Eleganter ist die Verwendung eines \swiftinline{NSNumberFormatter}. Solche Formatter, wie auch der \swiftinline{NSDateFormatter}, berücksichtigen bspw. Gerätesprache und länderspezifische Einstellungen und sollten stets verwendet werden, wenn Benutzereingaben interpretiert oder Ausgaben generiert werden:
	\begin{swiftcode}
    let decimalNumberFormatter = NSNumberFormatter()
    decimalNumberFormatter.numberStyle = .DecimalStyle
    let s: String = "0.1"
    let f: Float? = decimalNumberFormatter.numberFromString(s)?.floatValue
	\end{swiftcode}


\item Der Initializer \swiftinline{UIColor(red:green:blue:alpha:)} von \swiftinline{UIColor} akzeptiert jeweils Werte zwischen 0 und 1.
\item Die Funktion \swiftinline{arc4random_uniform(n)} gibt eine Pseudozufallszahl $x$ mit $0<=x<n$ aus.
\item Wenn ein \swiftinline{UISwitch} betätigt wird, sendet dieser ein Event \swiftinline{UIControlEvent.ValueChanged}, so wie ein \swiftinline{UIButton} das Event \swiftinline{UIControlEvent.TouchUpInside} sendet. Dieses Event kann genauso mit einer IBAction verbunden werden. Mit einem Attribut \swiftinline{var randomTimer: NSTimer?} können wir dann die Methode für das zufällige Wechseln der Hintergrundfarbe implementieren:
\begin{swiftcode}
@IBAction func switchValueChanged(sender: UISwitch) {
    if sender.on {
        self.randomTimer = NSTimer.scheduledTimerWithTimeInterval(0.15, target: self, selector: "randomButtonPressed:", userInfo: nil, repeats: true)
    } else {
        self.randomTimer?.invalidate()
        self.randomTimer = nil
    }
}
\end{swiftcode}
	Somit wird periodisch die Methode \swiftinline{randomButtonPressed:} aufgerufen, die natürlich implementiert sein muss.

\end{exchinweise}

\end{excitem}

\end{exc}


\end{lecture}



\begin{lecture} % Lecture 4


\chapter{Versionskontrolle mit Git}

Im Skript sind die Vorzüge der Versionskontrolle mit Git beschrieben, deren Grundlagen wir anhand einer unserer Apps anwenden können.

\skriptref{Versionskontrolle mit Git}

\begin{enumerate}

\item Da Git in erster Linie ein Kommandozeilenprogramm ist, verwenden wir zunächst die Konsole. Später könnt ihr stattdessen auch bspw. die in Xcode integrierten Benutzeroberflächen verwenden. Öffnet die \emph{Terminal} App und navigiert in den Ordner, der das Xcode Projekt der \emph{Hello World} App beinhaltet. Dazu kann es hilfreich sein, zunächst \shinline{cd} zu tippen und den Ordner dann auf das Terminal Fenster zu ziehen, wobei der Pfad automatisch eingegeben wird.

\begin{shcode}
cd path/to/project
\end{shcode}

\item Bei Erstellung des Projektes wurde möglicherweise bereits die Option ausgewählt, ein Git Repository zu initialisieren. Mit \shinline{git status} können wir prüfen, ob hier bereits eines existiert und es ansonsten mit \shinline{git init} erstellen.

\begin{shcode}
git status
# Git Repository vorhanden:
>> On branch master
>> nothing to commit, working directory clean
# kein Git Repository vorhanden:
>> fatal: Not a git repository (or any of the parent directories): .git
git init
\end{shcode}

\item Wir fügen dem Repository nun zunächst eine \shinline{.gitignore} Datei hinzu, um verschiedene benutzerspezifische und temporäre Dateien des Xcode Projekts auszuschließen.

\begin{shcode}
touch .gitignore
open .gitignore
\end{shcode}

Kopiert die Vorlagen \emph{Xcode} \linkref{https://github.com/github/gitignore/blob/master/Global/Xcode.gitignore} und \emph{OSX} \linkref{https://github.com/github/gitignore/blob/master/Global/OSX.gitignore} in die \shinline{.gitignore} Datei.

Nun können wir einen Commit ausführen, um die Datei dem Repository hinzuzufügen.

\begin{shcode}
git add .gitignore
git commit -m "Added .gitignore file"
\end{shcode}

\item Jederzeit kann es hilfreich sein, die Situation des Git Repositories mit \shinline{git status} zu überprüfen. Zeigt ein Aufruf dieses Befehls noch ungesicherte Änderungen an, könnt ihr diese in einem weiteren Commit sichern:

\begin{shcode}
git add --all
git commit -m"Committed unsaved changes"
\end{shcode}

\shinline{git log} zeigt die letzten Commits in der Konsole an.

\item Nun können wir an unserem Projekt weiterarbeiten und Änderungen an Dateien vornehmen. Öffnet bspw. die Datei \emph{ViewController.swift} und fügt ihrer Implementierung folgendes Codesegment hinzu:

\begin{swiftcode}
override func viewDidLoad() {
    super.viewDidLoad()
    self.view.backgroundColor = UIColor.redColor()
}
\end{swiftcode}

Führt ihr die App nun aus, seht ihr einen roten Bildschirmhintergrund.

In der Konsole sehen wir mit \shinline{git status}, dass nun Änderungen vorliegen. Diese können wir in Form eines Commits im Git Repository speichern.

\begin{shcode}
git add ViewController.swift # oder git add --all
git commit -m "changed background color"
\end{shcode}

\item Es gibt viele verschiedene Möglichkeit der Commitnavigation und -manipulation. Wir können bspw. mit \shinline{git checkout} einen bestimmten Commit laden, mit \shinline{git reset} Commits entfernen oder sie mit \shinline{git revert} in Form eines neuen Commits rückgängig machen. Dabei können wir einen bestimmten Commit anhand seines SHA hashs identifizieren, der bspw. mit \shinline{git log} angezeigt wird, oder mit \shinline{HEAD~x} den x-letzten Commit auswählen. Setzen wir den soeben ausgeführten Commit nun also bspw. zurück:

\begin{shcode}
git reset --hard HEAD~1 # Verwendet diesen Befehl nicht leichtfertig, denn hier gibt es keine Undo-Funtion!
\end{shcode}

In der Dokumentation \linkref{http://git-scm.com/book/} kann sich ausführlich über die verschiedenen Möglichkeiten informiert werden.

\item Häufig wird Git zur Projektstrukturierung in Form von \strong{Feature Branches} eingesetzt. Nehmen wir also an unser Projekt liegt in seiner veröffentlichten Form vor. Möchten wir nun ein neues Feature implementieren oder Umstrukturierungen vornehmen, erstellen wir zunächst einen neuen Branch mit \shinline{git branch}. Mit \shinline{git checkout} wechseln wir das Arbeitsverzeichnis in diesen neuen Branch.

\begin{shcode}
git branch new_feature
git checkout new_feature
\end{shcode}

\item Nun können wir in diesem Branch an unserem Projekt arbeiten, ohne andere Branches wie den zuvor verwendeten \shinline{master} Branch zu verändern. Implementiert  wieder eine Änderung und führt einen Commit durch:

\begin{swiftcode}
override func viewDidAppear(animated: Bool) {
    super.viewDidLoad()
    let alertController = UIAlertController(title: "New Feature!", message: "Is it a bug or a feature?", preferredStyle: .Alert)
    alertController.addAction(UIAlertAction(title: "Bug", style: .Destructive, handler: nil))
    alertController.addAction(UIAlertAction(title: "Feature", style: .Default, handler: nil))
    self.presentViewController(alertController, animated: animated, completion: nil)
}
\end{swiftcode}

\begin{shcode}
git commit -a -m "implemented new feature" # Der -a Flag fügt dem Commit automatisch alle veränderten Dateien hinzu
\end{shcode}

\item Erhalten wir nun plötzlich eine Email eines aufgebrachten Benutzers unserer App, der einen Fehler gefunden hat, können wir problemlos zurück zum \shinline{master} Branch wechseln und diesen schnell beheben:

\begin{shcode}
git checkout master
\end{shcode}

Nachdem wir zurück zum \shinline{master} Branch gewechselt haben, sehen wir, dass die Änderungen des \shinline{new_feature} Branches verschwunden sind. Stattdessen befindet sich der Code wieder in seinem ursprünglichen Zustand. Wir können den Fehler also beheben, einen Commit ausführen und die App in der neuen Version veröffentlichen, um den Emailschreiber zu besänftigen.

Anschließend wechseln wir wieder in unseren Feature Branch und arbeiten dort weiter, wo wir unterbrochen wurden.

\begin{shcode}
git checkout new_feature
\end{shcode}

\item Befindet sich der Feature Branch in einem Zustand, der veröffentlicht werden soll, muss er nur mit dem \shinline{master} Branch vereinigt werden. Dazu führen wir einen Merge durch.

\begin{shcode}
git checkout master
git merge new_feature
\end{shcode}

Wurden im \shinline{master} Branch keine weiteren Commits hinzugefügt, können die Commits des Feature Branches einfach angehängt werden (\emph{Fast-Forward}). Gehen die Branches jedoch auseinander, versucht Git, die Änderungen zusammenzuführen. Mögliche Konflikte müssen dabei wie im Skript beschrieben im Code behoben werden.

Der Feature Branch kann anschließend gelöscht werden:

\begin{shcode}
git branch -d new_feature
\end{shcode}

\item Versionskontrolle ist nicht nur für größere Projekte essentiell und hilft bei der Entwicklung jeder iOS App, sondern ermöglicht auch die Zusammenarbeit mehrerer Entwickler an einem Projekt. Im Skript ist dieses Thema kurz beschrieben und auch auf den Service GitHub \linkref{http://www.github.com} verwiesen, der weltweit von Entwicklern verschiedenster Plattformen verwendet wird, um an Projekten zusammenzuarbeiten.

Auf GitHub ist bspw. auch dieses Skript zu finden. Ihr könnt das Repository auf der Webseite einsehen \linkref{https://github.com/iOS-Dev-Kurs/Skript} und herunterladen.

Navigiert dazu in der Konsole zu dem Verzeichnis eurer Projekte für diesen Kurs und führt einen \shinline{git clone} aus:

\begin{shcode}
cd path/to/directory
git clone https://github.com/iOS-Dev-Kurs/Skript
\end{shcode}

Das Repository wird dabei in das angegebene Verzeichnis heruntergeladen. Im Unterverzeichnis \shinline{dist/} findet ihr die gesetzten Dokumente dieses Kurses in aktueller Version. Auch die Links auf der Vorlesungsseite verlinken auf diese Dateien.

Prinzipiell könnt ihr nun lokal an dem Repository weiterarbeiten und Commits durchführen, diese jedoch nicht hochladen. Zur Zusammenarbeit an Programmierprojekten werden entweder entsprechende Berechtigungen vergeben, oder das \strong{Fork} System auf GitHub verwendet.

Wenn ich nun Änderungen am Remote Repository auf Github vornehme, also bspw. eine neue Version dieses Skript veröffentliche, können ihr diese mit nur einem Befehl laden und mit dem lokalen \shinline{master} Branch zusammenführen:

\begin{shcode}
git pull
\end{shcode}

\end{enumerate}

\begin{exc}

\begin{excitem}{chatter}{Chatter}{2}

In dieser Aufgabe schreiben wir zusammen an einer App!

\begin{exchinweis}
Aus naheliegenden Gründen funktioniert es insgesamt besser, wenn ihr diese Aufgabe nicht alle erst am Sonntagabend erledigt…
\end{exchinweis}

\begin{enumerate}[label=\roman*.]

\item Auf GitHub verwalte ich das Repository der \emph{chatter} App \linkref{https://github.com/iOS-Dev-Kurs/chatter}. Ihr könnt es zwar in dieser Form mit \shinline{git clone} herunterladen, jedoch keine Änderungen im Original-Repository auf dem Server veröffentlichen. Stattdessen benötigt ihr einen eigenen \strong{Fork}, mit dem ihr arbeiten könnt. Erstellt dazu zunächst einen GitHub Account \linkref{https://github.com/join}, wenn ihr noch keinen habt.

\item Loggt euch mit eurem GitHub Account ein und befolgt die Anweisungen der GitHub Dokumentation \linkref{https://help.github.com/articles/fork-a-repo}, um einen Fork des \emph{chatter} Repositories \linkref{https://github.com/iOS-Dev-Kurs/chatter} zu erstellen. Dort ist insbesondere auch beschrieben, wie ihr das Repository anschließend lokal klont und das Original-Repository als Remote \shinline{upstream} hinzufügt.

\item Ihr habt das Projekt nun lokal auf eurem Mac. Es ist sowohl mit eurem Fork des Repositories (\shinline{origin}) als auch mit meinem Original-Repository (\shinline{upstream}) verbunden. Ihr könnt jetzt jederzeit die Änderungen herunterladen, die ich oder andere Teilnehmer unseres Kurses am Original-Repository vornehmen, indem ihr von \shinline{upstream} pullt:

\begin{shcode}
git pull --rebase upstream master # Ein Rebase ist hier angebrachter als ein Merge, im Skript ist der Unterschied kurz beschrieben
\end{shcode}

Dies solltet ihr häufig tun, unter anderem immer bevor ihr beginnt, an dem Projekt zu arbeiten.

\item Falls ihr es noch nicht getan habt, solltet ihr euren Namen und eure GitHub Email der Git Konfiguration hinzufügen, sodass die Commits ordentlich eurem Account zugeordnet werden

\begin{shcode}
git config --global user.name "__dein_name__"
git config --global user.email __deine_github_email___
\end{shcode}

\item Öffnet nun das Projekt in Xcode. Die \emph{chatter} App ist in der im Repository enthaltenen \emph{README.md} Datei beschrieben. Diese und die Kommentare im Code sollen euch bezüglich der App als Referenz dienen. Ihr könnt euch die Projektdateien anschauen und die App im Simulator oder auf euren Geräten ausführen und ausprobieren.

\item Ihr habt nun sicherlich erkannt, worum es in der App geht: Instanzen verschiedener Subklassen von \swiftinline{Chatter} chatten miteinander. Dabei überschreiben die Subklassen jeweils nur die Implementierung weniger Methoden, die in der \swiftinline{Chatter} Klasse dokumentiert sind.

Eure Aufgabe ist es nun, eine eigene Subklasse zu schreiben und sie mithilfe von Git den anderen zur Verfügung zu stellen! Ihr könnt bspw. versuchen, einen bekannten Charakter darzustellen, oder etwas völlig neues erschaffen. Lasst eurer Kreativität freien Lauf!

Erstellt dazu einfach eine neue Subklasse von \swiftinline{Chatter} mit dem Namen eures Charakters und platziert die \shinline{.swift}-Datei im Xcode Projekt Navigator unter \menu{chatter > Model > Chatters}.

\item Überschreibt nun die relevanten Methoden wie in der \emph{README.md} Datei beschrieben. Hier könnt ihr einfach zufällige Chatnachrichten generieren, oder auch komplexere Mechaniken einbauen, sodass eine etwas natürlichere Konversation zustande kommt.

In eurer eigenen Subklasse könnt ihr dabei beliebig Code schreiben und bspw. Attribute einführen, um den Zustand eures Charakters darzustellen, wenn ihr möchtet. Wenn es nötig ist, könnt ihr auch die \objcinline{Message} Klasse leicht anpassen. Achtet dabei jedoch unbedingt darauf, dass der Code für die anderen ebenfalls noch funktionieren muss!

\item Sichert eure Änderungen regelmäßig in Commits, wenn der Code fehlerfrei kompiliert:

\begin{shcode}
git add filename # Achtet bitte darauf, nur Änderungen eurer Subklasse und nur wenn nötig Änderungen in anderen Dateien zu committen. Die project.pbxproj Datei enthält Informationen zu den Projektdateien - da ihr neue Dateien hinzugefügt habt, müsst ihr diese auch committen.
git status # häufig den Status prüfen
git commit -m"describe your changes here"
\end{shcode}

\item Die neuen Commits entstehen zunächst nur lokal. Mit eurem Fork des Repositories auf GitHub könnt (und solltet) ihr diese jedoch jederzeit abgleichen. Bei der Gelegenheit bietet es sich an, wie zuvor beschrieben zunächst die neuesten Änderungen aus dem Original-Repository herunterzuladen:

\begin{shcode}
git pull --rebase upstream master
\end{shcode}

Das Repository enthält dann sowohl den aktuellen Stand des Original-Repositories, als auch eure Änderungen. Dies könnt ihr auf euren Fork auf GitHub hochladen:

\begin{shcode}
git push origin master
\end{shcode}

\item Wenn ihr mit eurer neuen \swiftinline{Chatter} Subklasse zufrieden sein, schickt mir eine \emph{Pull Request}. So werden eure Änderungen in das Original-Repository integriert und tauchen auch bei den anderen Teilnehmern auf, wenn diese das nächste mal einen \shinline{git pull} durchführen.

GitHub beschreibt das System der Pull Requests recht ausführlich in ihrer Dokumentation \linkref{https://help.github.com/articles/using-pull-requests}. Wie dort beschrieben, müsst ihr den Prozess dazu mit Klick auf den \emph{Compare \& review} Button initiieren, noch einmal die Änderungen prüfen und anschließend absenden. Ich erhalte dann eine Benachrichtigung und muss dem Merge mit dem Original-Repository nur noch großzügig zustimmen.

Ich bin gespannt auf eure Implementierungen!

\end{enumerate}

\end{excitem}

\end{exc}


\end{lecture}



\begin{lecture} % Lecture 5


\chapter{View Hierarchie}

Die iOS App Entwicklung orientiert sich konsequent am \emph{Model-View-Controller Konzept} der Programmierung. Es ist nicht nur in Apples Frameworks wie \swiftinline{UIKit} rigoros umgesetzt sondern stellt auch die Grundlage für die weitere Konzeption unserer Apps dar und wird auch in vielen anderen Bereichen der Softwareentwicklung verwendet. Das Konzept ist im Skript beschrieben und sollte bei Entscheidungen zur Architektur einer App stets als Referenz verwendet werden.

\skriptref{Das Model-View-Controller Konzept}

Wir betrachten nun zunächst die \emph{View} Komponente des Konzepts. Im Skript wird die \swiftinline{UIView} Klasse des \swiftinline{UIKit} Frameworks vorgestellt, die mit ihren Subklassen die Anzeige von Interfaceelementen auf dem Bildschirm übernimmt. Wir werden in diesem Kapitel die \emph{View Hierarchie} kennenlernen, \swiftinline{UIView} Objekte erstellen und anzeigen, sowie mithilfe des \emph{Auto Layout} Konzepts das User Interface dynamisch anpassen.



\section{Handgeschriebene View Hierarchie}

\mvcindicatorview

\skriptref{View Hierarchie}

\begin{enumerate}
\item Ihr könnt das MVC-Konzept noch nicht im Schlaf rezitieren? Unbedingt erstmal im Skript nachlesen!
\item Zuvor haben wir für Xcode Projekte ein Template mit vorkonfiguriertem Target, Storyboard und View Controller verwendet. Für den allgemeinen Gebrauch sind solche Templates sehr sinnvoll, doch nun möchten wir die Architektur einer iOS App einmal genauer untersuchen. Verwendet dafür das \shinline{viewhierarchy_bare} Projekt, das auf der Vorlesungsseite zur Verfügung steht.
\item Das Projekt beinhaltet nur ein Target \shinline{viewhierarchy} und zwei Dateien: eine Konfigurationsdatei \shinline{Info.plist} und eine mit dem \emph{Entry Point} Attribut \swiftinline{@UIApplicationMain} als \emph{Application Delegate} markierte Klasse \swiftinline{AppDelegate}. Im Skript könnt ihr euch über den Startprozess einer iOS App informieren.

Implementieren wir die \swiftinline{application:didFinishLaunchingWithOptions:} Methode des Application Delegates, wird diese am Ende des Startvorgangs aufgerufen:

\begin{swiftcode}
@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?

    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {        
        NSLog("Hello World!")
        return true
    }
}	
\end{swiftcode}

\item Da wir in der \shinline{Info.plist} Datei kein Storyboard angeben, wird beim Start der App einfach ein leeres \swiftinline{UIWindow} erstellt und angezeigt. Das können wir auch selbst tun:

\begin{swiftcode}
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
    let window = UIWindow(frame: UIScreen.mainScreen().bounds)
    window.backgroundColor = UIColor.whiteColor()
    window.makeKeyAndVisible()
    self.window = window
    return true
}
\end{swiftcode}

\item Nun können wir die View Hierarchie des angezeigten \swiftinline{UIWindow} mit weiteren Objekten der Superklasse \swiftinline{UIView} füllen und diese somit auf dem Bildschirm anzeigen:
\begin{swiftcode}
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
    let window = UIWindow(frame: UIScreen.mainScreen().bounds)
    window.backgroundColor = UIColor.whiteColor()
    window.makeKeyAndVisible()
    self.window = window
    
    let label = UILabel(frame: CGRect(x: 0, y: 50, width: window.frame.size.width, height: 50))
    label.text = "Hello World!"
    label.backgroundColor = UIColor.redColor()
    window.addSubview(label)
    
    let button = UIButton(frame: CGRect(x: window.frame.size.width / 2 - 40, y: 120, width: 80, height: 44))
    button.backgroundColor = UIColor.blackColor()
    button.setTitle("Click!", forState: .Normal)
    button.addTarget(self, action: "clickButtonPressed:", forControlEvents: .TouchUpInside) // Diese Methode ist das Äquivalent einer IBAction Verbindung
    window.addSubview(button)
    
    return true
}

func clickButtonPressed(sender: UIButton) {
    println("Click!")
}
\end{swiftcode}

\end{enumerate}

\begin{exc}

\begin{excitem}{view_hierarchy}{Color Match}{2+1}

Verwendet das \shinline{viewhierarchy_bare} Projekt als Ausgangspunkt um (ohne den Interface Builder zu verwenden) eine einfache App zu schreiben. Denkt euch etwas eigenes aus (das kann jedoch schnell komplex werden), oder implementiert das folgende einfache Spiel:

Auf dem Bildschirm werden Buttons angezeigt, die jeweils eine Farbe als Hintergrund und den Namen einer (ggfs. anderen!) Farbe als Titel tragen. Man muss nun versuchen, auf solche Buttons zu tippen, deren Farbe und Titel übereinstimmen.

\strong{Bonus [+1]:} Verwendet dabei Git, um euer Projekt in Form von Commits zu sichern und stellt es zur Abgabe auf GitHub zur Verfügung.

Nach dem MVC-Konzept trennen wir die Implementierung von Modell, Präsentation und Steuerung:

\begin{description}
	\item[Model] Erstellt eine Swift Datei \shinline{ColorWord.swift} und implementiert ein Struct \swiftinline{ColorWord} mit zwei Attributen \swiftinline{color: UIColor} und (Überraschung!) \swiftinline{word: String}. Das Struct benötigt zusätzlich einen Initializer \swiftinline{init()}, der eine zufällige Kombination erstellt, sowie ein Computed Attribute \swiftinline{isCorrect: Bool}, das prüft, ob Farbe und Wort zusammenpassen.
	\item[View] Implementiert eine Subklasse \swiftinline{ColorButton: UIButton} in einer weiteren Swift Datei. Diese benötigt nur eine Methode \swiftinline{configureForColorWord:}, die eine Instanz \swiftinline{colorWord: ColorWord} als Argument annimmt und die \swiftinline{backgroundColor} und \swiftinline{title} Attribute, die von \swiftinline{UIButton} geerbt werden, entsprechend setzt.
	\item[Controller] Der Steuerungscode wird normalerweise in Subklassen von \swiftinline{UIViewController} geschrieben, doch hier verwenden wir einfach die \swiftinline{AppDelegate} Klasse.
	
	Fügt der \swiftinline{AppDelegate} Klasse die Attribute \swiftinline{var score: Int}, \swiftinline{var rounds: Int}, \swiftinline{var timer: NSTimer?}, sowie \swiftinline{var scoreLabel: UILabel!} und \swiftinline{var colorButtons: [ColorButton]} hinzu.
	
	Das Spiel kann nun bspw. so ablaufen:
	
	\begin{enumerate}
		\item In \swiftinline{application:didFinishLaunchingWithOptions:} wird das \swiftinline{window} und das \swiftinline{scoreLabel} erstellt und konfiguriert.
		\item Dann wird (ggfs. mehrmals) eine Methode \swiftinline{addColorButton} aufgerufen, die einen solchen Button erstellt und dem Array \swiftinline{colorButtons} sowie der View Hierarchie hinzufügt. Überlegt euch, wie ihr den Button positioniert. Wenn der Button betätigt wird, soll \swiftinline{colorButtonPressed:} aufgerufen werden.
		\item Die Methode \swiftinline{colorButtonPressed(sender: ColorButton)} muss dann natürlich implementiert werden. Prüft bspw., ob die Kombination des betätigten Buttons korrekt ist, um entsprechend Punkte von \swiftinline{score} abzuziehen oder hinzuzufügen. Anschließend soll eine Methode \swiftinline{prepareNextRound} aufgerufen werden.
		\item \swiftinline{prepareNextRound} fügt zunächst gegebenenfalls weitere Buttons mit \swiftinline{addColorButton} hinzu, um den Schwierigkeitsgrad zu erhöhen. Dann soll jeder angezeigte Button mit einem neuen \swiftinline{ColorWord} konfiguriert werden und ein Timer gestartet werden:
		\begin{swiftcode}
    func prepareNextRound() {
        self.rounds++
        // ...
        if let timer = self.timer {
            timer.invalidate()
        }
        self.timer = NSTimer.scheduledTimerWithTimeInterval(/* Zeit in sec */, target: self, selector: "timerFired:", userInfo: nil, repeats: false)
    }
		\end{swiftcode}
		\item Die Methode \swiftinline{timerFired(timer: NSTimer)} wird nun nach Ablauf des Timers aufgerufen und muss implementiert werden. Hier können bspw. Punkte von der \swiftinline{score} abgezogen werden, wenn ein Button die korrekte Kombination trägt. Anschließend soll wieder \swiftinline{prepareNextRound} aufgerufen werden.
		\item \swiftinline{prepareNextRound} könnt ihr auch am Ende der \swiftinline{application:didFinishLaunchingWithOptions:} Methode bereits aufrufen, um den ersten Timer zu starten.
		\item Das \swiftinline{scoreLabel} muss an entsprechenden Stellen aktualisiert werden, am besten mithilfe einer Methode \swiftinline{updateScoreLabel}.
	\end{enumerate}
	
	Um das Spiel interessant zu gestalten, gibt es natürlich an vielen Stellen noch Erweiterungspotential!

\end{description}

\end{excitem}

\end{exc}


\end{lecture}



\begin{lecture}


\section{Auto Layout}

\mvcindicatorview

Eine View Hierarchie können wir offenbar ebenso im Code schreiben wie im Storyboard konfigurieren. Selbst für ein simples Interface wie im vorherigen Abschnitt implementiert ist jedoch viel Code notwendig, da jeder Parameter als Attribut gesetzt werden muss. Der Interface Builder bietet hier effiziente Möglichkeiten, Benutzeroberflächen ohne Code zu konfigurieren und trotzdem mit dem Code zu verknüpfen.

Eine große Stärke des Interface Builders zeigt sich auch bei der Implementierung von dynamischen Benutzeroberflächen. Um auf Änderungen der Darstellung, wie bspw. Orientierungswechsel von Portrait auf Landscape, zu reagieren, müssten wir extensiv Code schreiben und die Frames der Views unserer View Hierarchie berechnen.

iOS Apps verwenden das \emph{Auto Layout} Konzept von \swiftinline{UIKit}. Anstatt manuell Frames zu berechnen, definieren wir Regeln, die das Layout unserer Views erfüllen soll. Dieses Konzept der \emph{Constraints} ist im Skript detailliert beschrieben. Mit \emph{Size Classes} kann das Interface dann für bestimmte Displaygrößen genauer angepasst werden.

\skriptref{Auto Layout}

\begin{enumerate}

\item Betrachten wir die RGB App als Beispiel für eine der zuvor konfigurierten einfachen Benutzeroberflächen. Ihr könnt auch das Projekt einer anderen App mit vergleichsweise einfachem Interface öffnen. Rotieren wir den Simulator mit \keys{\cmd+\arrowkeyright} oder \keys{\cmd+\arrowkeyleft} in die Landscape Orientierung, werden die Frames der einzelnen Views nicht verändert und die Benutzeroberfläche wird nicht wie gewünscht angezeigt \abbref{img:autolayout_rgb_pre}.

\includegraphicsc[.6\textwidth]{img/autolayout_rgb_pre.png}{img:autolayout_rgb_pre}{In der Landscape Orientierung bleiben die absoluten Frames einfach erhalten.}

\item Um das Problem zu lösen, können wir nach dem Auto Layout Konzept nun Constraints definieren und damit \swiftinline{NSLayoutConstraint} Objekte der Superview hinzufügen. Zur Laufzeit positioniert die Superview ihre Subviews dann automatisch, sodass diese Constraints erfüllt sind. Die einfachste Möglichkeit zur Erstellung von Constraints bietet der Interface Builder.

	Im Storyboard stellen wir zunächst sicher, dass Auto Layout für diese Interface Builder Datei aktiviert ist. Dazu muss die Option \emph{Use Autolayout} im File Inspector markiert sein.

\item Nun können wir Constraints zwischen Interfaceelementen nach unseren Vorstellungen definieren. Dazu verwenden wir die Schaltflächen am rechten unteren Bildschirmrand oder ziehen Verbindungslinien zwischen Objekten bei gehaltener \keys{\ctrl}-Taste. Im Skript sind die Möglichkeiten bei der Erstellung von Constraints beschrieben.

\item In einem eindeutigen Layout werden die Constraints blau markiert. Entsprechen nur die Frames nicht den Constraints, erscheinen diese in gelb und ihr könnt das \emph{Resolve Auto Layout Issues} Menü am unteren rechten Bildschirmrand verwenden, um mit einem Klick auf \emph{Update Frames} alle Views entsprechend ihrer Constraints zu positionieren. Bei einem eindeutigen Layout werden die Frames automatisch angepasst, wenn ihr die Konstanten der Constraints verändert. Sind Constraints rot gefärbt, gibt es Konflikte!

Fügt so lange passende Constraints hinzu, bis das Layout dadurch eindeutig beschrieben wird. \strong{Überlegt euch dabei für jede Subview genau, welche Constraints ihr benötigt, um die vier Parameter \swiftinline{x}, \swiftinline{y}, \swiftinline{width} und \swiftinline{height} von \swiftinline{frame} eindeutig festzulegen.} Beachtet die \emph{Intrinsic Content Size}!

\item Je nach Layout kann es nun sinnvoll sein, die Constraints für bestimmte \emph{Size Classes} anzupassen. Sollen einige Interfaceelemente bspw. auf einem breiteren Display nebeneinander statt untereinander positioniert werden, wählen wir zunächst die \emph{horizontal Regular, vertikal Any} Size Class mithilfe der Schaltfläche am unteren Rand des Editorbereichs.

\item Änderungen, die wir nun am Layout durchführen, betreffen nur die Anzeige in dieser Size Class. Wir können also die Interfaceelemente verschieben und Constraints verändern, bis uns das Layout für breite Displays gefällt.

\item Führt die App nun auf den iPhone und iPad Simulatoren aus und testet euer Layout bei verschiedenen Displaygrößen und -orientierungen.

\end{enumerate}

\begin{exc}

\begin{excitem}{autolayout}{Auto Layout}{3}

Fügt eurer Counter, BMI oder RGB App oder einer vergleichbar einfachen App im Storyboard passende Constraints hinzu, sodass die Benutzeroberfläche sowohl in Portrait und Landscape Orientierung als auch bei verschiedenen Displaygrößen sinnvoll angezeigt wird. Dabei sollte das Layout eurer View Hierarchie eindeutig durch Constraints definiert sein. [1 P.]

Löst dann die folgenden Layouts durch geschickte Definition von Constraints. [2 P.]

\begin{exchinweise}
\item Ihr könnt ein neues Projekt \shinline{AutoLayout} nach dem \emph{Single View} Template erstellen und dem Storyboard einfach für jedes Problem ein \emph{View Controller} Objekt aus der Object Library hinzufügen. Dessen View Hierarchie könnt ihr dann im Storyboard mit Views und Constraints konfigurieren. Mit den Schaltflächen im \emph{Simulated Metrics} Abschnitt des \emph{Attribute Inspectors}, könnt ihr bei ausgewähltem View Controller eine Gerätegröße und -orientierung simulieren.
\item In einigen Situationen kann die Verwendung von unsichtbaren Views als Platzhalter hilfreich sein. Dafür kann das Attribut \objcinline{hidden} verwendet werden, das auch im Interface Builder verfügbar ist.
\end{exchinweise}

\begin{enumerate}

\item Eine \swiftinline{UISegmentedControl} und eine \swiftinline{UIProgressView} sind am oberen Bildschirmrand positioniert, eine \swiftinline{UIView} füllt den verbliebenen Platz.

\begin{minipage}{.5\linewidth}
  \centering
  \includegraphics[width=\linewidth, height=\linewidth, keepaspectratio]{img/al_21.png}
\end{minipage}
\begin{minipage}{.5\linewidth}
  \centering
  \includegraphics[width=\linewidth, height=\linewidth, keepaspectratio]{img/al_22.png}
\end{minipage}

\item Zwei Buttons im Abstand von 20pt sind am oberen Bildschirmrand \strong{zusammen} horizontal zentriert. Ein \swiftinline{UISlider} mit zugehörigem Label und eine füllende View befinden sich darunter. Ändern wir den Text der Label, passt sich das Layout an.

\begin{minipage}{.5\linewidth}
  \centering
  \includegraphics[width=\linewidth, height=\linewidth, keepaspectratio]{img/al_31.png}
\end{minipage}
\begin{minipage}{.5\linewidth}
  \centering
  \includegraphics[width=\linewidth, height=\linewidth, keepaspectratio]{img/al_32.png}
\end{minipage}

\item Zwei Views haben (Platzhalter-) Intrinsic Content Sizes von 300x300pt und 100x100pt. Die größere wird wenn möglich vertikal zentriert, hat jedoch immer einen Abstand von mindestens 20pt zur darunter befindlichen kleineren View. Beide sind horizontal zentriert. Die kleinere View ist außerdem immer mindestens 20pt vom unteren Bildschirmrand entfernt. Wird der verfügbare Platz kleiner, wird die größere View vor der kleineren gestaucht.

\begin{minipage}{.5\linewidth}
  \centering
  \includegraphics[width=\linewidth, height=\linewidth, keepaspectratio]{img/al_11.png}
\end{minipage}
\begin{minipage}{.5\linewidth}
  \centering
  \includegraphics[width=\linewidth, height=\linewidth, keepaspectratio]{img/al_13.png}
\end{minipage}

\item Drei Views füllen jeweils den verfügbaren vertikalen Platz mit einem Abstand von 20pt zur Begrenzung. Horizontal sind sie gleichmäßig verteilt.

\begin{minipage}{.5\linewidth}
  \centering
  \includegraphics[width=\linewidth, height=\linewidth, keepaspectratio]{img/al_02.png}
\end{minipage}
\begin{minipage}{.5\linewidth}
  \centering
  \includegraphics[width=\linewidth, height=\linewidth, keepaspectratio]{img/al_01.png}
\end{minipage}

\end{enumerate}

\end{excitem}

\end{exc}


\end{lecture}


\begin{lecture}


\chapter{Cities}

\mvcindicatorcontroller

iOS Apps bestehen im Allgemeinen nicht nur aus einer, sondern aus einer Vielzahl von untereinander verbundenen Bildschirmansichten. Wir haben gelernt, dass jede Komponente der Benutzeroberfläche letztendlich von einem \swiftinline{UIView} Objekt in der View Hierarchie des übergeordneten \swiftinline{UIWindow} Objekts dargestellt wird.

Nun können wir die View Hierarchie einer komplexen App natürlich nicht wie im vorherigen Abschnitt zentral im App Delegate verwalten \excref{exc:view_hierarchy}. Um eine sinnvolle Struktur zu schaffen, implementieren wir stattdessen \emph{View Controller}.

Diese sind der Controller-Komponente des Model-View-Controller Konzepts zugeordnet und im Skript ausführlich beschrieben.

Mit dieser App lernen wir das \emph{View Controller Containment} Prinzip kennen, schreiben eigene \swiftinline{UIViewController} Subklassen und verwenden einige wichtige View Controller aus dem UIKit Framework.

\skriptref{View Controller Hierarchie}

\section{One City}\label{sec:one_city}

Wir wollen zunächst einen Buttons mit dem Titel einer Stadt implementieren und Informationen über die entsprechende Stadt in einem separaten View Controller anzeigen, wenn der Benutzer auf den Button drückt.

\begin{enumerate}

\item Beginnen wir mit einem neuen Xcode Projekt nach dem \emph{Single View} Template und mit dem Product Name \emph{Cities}. Es wird damit automatisch eine Klasse \swiftinline{AppDelegate} und ein Storyboard hinzugefügt. Zusätzlich befindet sich bereits eine Subklasse \swiftinline{ViewController: UIViewController} in unserem Projekt.

\item Die Klasse \swiftinline{ViewController} benennen wir zunächst in \swiftinline{CitiesViewController} um. Dazu muss sowohl die Swift-Datei in \filename{CitiesViewController.swift} als auch der Klassenname in \swiftinline{CitiesViewController: UIViewController} umbenannt werden. Außerdem muss die Klasse im Storyboard angepasst werden (s.u.).

\item Im Storyboard finden wir eine Scene mit einem View Controller. Wie im Skript beschrieben, können wir die zu verwendende \swiftinline{UIViewController} Subklasse im Identity Inspector (\keys{\cmd+\Alt+3}) einstellen. Gebt hier bei ausgewähltem View Controller unter \menu{Custom Class > Class} den Namen \str{CitiesViewController} ein.

Zur Laufzeit wird also ein Objekt dieser Subklasse erzeugt und dem \swiftinline{UIWindow} Objekt als Root View Controller zugeordnet, da die Scene als \emph{Initial Scene} gekennzeichnet ist. Damit wird die Content View dieses View Controllers zu Beginn der Ausführung der App der View Hierarchie des \swiftinline{UIWindow} Objekts hinzugefügt.

\item Ziehen wir nun \swiftinline{UIView} Objekte auf die Content View des View Controllers, werden diese zur View Hierarchie der Content View hinzugefügt. Der View Controller ist für die Verwaltung seiner Content View zuständig. Daher stellen wir Verbindungen in Form von IBOutlets und IBActions her, um Zugriff auf die Objekte zu erhalten und um auf Benutzereingaben reagieren zu können.

Wir benötigen zunächst nur ein \swiftinline{UIButton} Objekt mit entsprechendem IBOutlet, das den Namen einer beliebigen Stadt anzeigen soll \abbref{img:one_city_ui}. Als Titel des Buttons könnt ihr auch zunächst generisch \str{City name} o.ä. wählen, da wir diesen im Code anpassen.

\includegraphicsc[\iphonewidth]{img/one_city_ui.png}{img:one_city_ui}{Ein Button soll bei Betätigung Informationen über die entsprechende Stadt anzeigen}

\item Obwohl wir uns in dieser App hauptsächlich mit der Controller-Komponente beschäftigen, sollten wir eine einfache Datenstruktur implementieren, die zu unserer App passt. So können wir Daten einfacher verarbeiten und weitergeben. Erstellt also in einer neuen Swift Datei ein \swiftinline{struct City} und definiert die Attribute \swiftinline{let name: String} und \swiftinline{let image: UIImage?}.

\begin{swiftcode}
// City.swift
import UIKit

struct City {
    let name: String
    let image: UIImage?
}
\end{swiftcode}

\item Später wird der Cities View Controller eine Liste von Städten anzeigen, doch zunächst beschränken wir uns auf eine einzelne. Fügt \swiftinline{CitiesViewController} daher ein Attribut \swiftinline{var city: City?} hinzu:

\begin{swiftcode}
// CitiesViewController.h
import UIKit

class CitiesViewController: UIViewController {
    var city: City?
    @IBOutlet var cityButton: UIButton!
}
\end{swiftcode}

\item Wir verwenden nun das App Delegate, um zu Beginn der Ausführung der App das Model, also die \swiftinline{City} Objekte, aufzusetzen und an die View Controller Hierarchie weiterzugeben. Implementiert daher folgende \swiftinline{application:didFinishLaunchingWithOptions:} Methode.

\begin{swiftcode}
// AppDelegate.swift
import UIKit

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?
    
    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
        let melbourne = City(name: "Melbourne", image: UIImage(named: "melbourne"))
        if let citiesViewController = window?.rootViewController as? CitiesViewController {
            citiesViewController.city = melbourne
        }
        return true
    }
}

\end{swiftcode}

Es gibt natürlich auch Städte in Mittelerde, Panem und auf Naboo…

\strong{Hinweis:} Der Initializer \swiftinline{init(named: String)} von \swiftinline{UIImage} lädt die Bilddatei mit dem angegebenen Dateinamen, sofern die Datei im Target referenziert ist. Um dem Target eine Bilddatei hinzuzufügen, könnt ihr sie einfach auf die Dateiliste des Project Navigators ziehen. Praktischer und ressourcenschonender ist jedoch die Verwendung von \emph{Xcode Asset Catalogs} für die Bilddateien einer App. Eine solche mit Dateiendung \filename{.xcassets} ist bereits im Projekt enthalten. Diese Datei könnt ihr öffnen und auf den Bereich links im Editor per \emph{Drag \& Drop} einfach Bilddateien hinzufügen.

\item Im Cities View Controller überschreiben wir die \swiftinline{viewWillAppear:} Methode, um das Interface entsprechend des \swiftinline{City} Objekts zu konfigurieren.

\begin{swiftcode}
// CitiesViewController.swift
import UIKit

class CitiesViewController: UIViewController {
    var city: City?
    @IBOutlet var cityButton: UIButton!
    
    override func viewWillAppear(animated: Bool) {
        cityButton.setTitle(city?.name, forState: .Normal)
    }
}

\end{swiftcode}

Führt ihr die App an dieser Stelle mit einem \emph{Build \& Run} aus, wird der Button mit dem Namen der Stadt konfiguriert und angezeigt.

\item Um nun auf Knopfdruck einen Bildschirm zu präsentieren, der die Informationen der ausgewählten Stadt anzeigt, implementieren wir eine weitere Subklasse von \swiftinline{UIViewController}. Erstellt also eine neue Klasse \swiftinline{CityDetailViewController: UIViewController}. Dieser Klasse übergeben wir das ausgewählte \swiftinline{City} Objekt und überlassen ihr die Konfiguration ihrer Content View entsprechend den Attributen des Objekts. Definiert also wieder ein Attribut \swiftinline{var city: City?} im Header der \swiftinline{CityDetailViewController} Klasse.

\begin{swiftcode}
// CityDetailViewController.h
import UIKit

class CityDetailViewController: UIViewController {
    var city: City?
}
\end{swiftcode}

\item Nun verwenden wir das Storyboard, um die Benutzerführung zu konfigurieren. Zieht ein View Controller Objekt aus der Object Library auf das Storyboard und platziert es neben dem Cities View Controller. Wählt im Identity Inspector des hinzugefügten View Controllers wie zuvor das Eingabefeld \emph{Class} und gebt den Namen der neuen \swiftinline{UIViewController} Subklasse \str{CityDetailViewController} ein.

\item Platziert ein \swiftinline{UILabel} und ein \swiftinline{UIImageView} Objekt in der Content View des \swiftinline{CityDetailViewController} und verbindet sie mit IBOutlets im Code \abbref{img:city_detail_ui}. Fügt außerdem einen \str{Zurück} Button hinzu.

\includegraphicsc[\iphonewidth]{img/city_detail_ui.png}{img:city_detail_ui}{Der City Detail View Controller soll Information über die ausgewählte Stadt anzeigen}

\begin{swiftcode}
// CityDetailViewController.swift
import UIKit

class CityDetailViewController: UIViewController {
    var city: City?

    @IBOutlet weak var nameLabel: UILabel!
    @IBOutlet weak var imageView: UIImageView!
}
\end{swiftcode}

\item Zur Präsentation des City Detail View Controllers können wir nun \emph{Segues} verwenden. Diese repräsentieren, wie im Skript beschrieben, Beziehungen zwischen einzelnen Scenes im Storyboard. Segues können analog zu IBOutlets und IBActions erstellt werden, indem eine Verbindungslinie mit gedrückter \keys{\ctrl}-Taste gezogen wird. Wählt den Button im Cities View Controller aus und zieht eine Verbindung zum City Detail View Controller \abbref{img:one_city_detail_segue}. Erstellt so eine \emph{Modal Segue} zwischen Button und View Controller (die Auswahlmöglichkeiten \emph{show}, \emph{show detail} und \emph{present modally} haben in diesem Fall die gleiche Wirkung). 

\includegraphicsc{img/one_city_detail_segue.png}{img:one_city_detail_segue}{Eine Modal Segue konfiguriert die Präsentation des City Detail View Controllers bei Betätigung des Buttons}

Im Attributes Inspector könnt ihr die Segue konfigurieren und bspw. zwischen verschiedenen Übergangsanimationen auswählen. Hier kann außerdem ein \emph{Identifier} für die Segue vergeben werden. Setzt diesen auf \str{showCityDetail}.

\item Dem erstellten City Detail View Controller muss vor der Präsentation ein \swiftinline{City} Objekt übergeben werden, damit er dessen Attribute darstellen kann. Dazu implementieren wir die Instanzmethode \swiftinline{prepareForSegue:sender:} in unserer \swiftinline{CitiesViewController} Klasse.

\begin{swiftcode}
// CitiesViewController.swift
import UIKit

class CitiesViewController: UIViewController {
    // ...    
    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
        if let identifier = segue.identifier {
            switch identifier {
            case "showCityDetail":
                if let cityDetailViewController = segue.destinationViewController as? CityDetailViewController {
                    cityDetailViewController.city = self.city
                }
            default:
                break
            }
        }
    }
}
\end{swiftcode}

Hier geben wir das \swiftinline{City} Objekt also einfach an den City Detail View Controller weiter.

\item Schließlich müssen wir den City Detail View Controller für die Darstellung der Attribute des \swiftinline{City} Objekts konfigurieren. Dies geschieht am besten in einer Implementierung der \swiftinline{viewWillAppear:} Instanzmethode in der \swiftinline{CityDetailViewController} Klasse.

\begin{swiftcode}
// CityDetailViewController.swift
import UIKit

class CityDetailViewController: UIViewController {
    var city: City?

    @IBOutlet weak var nameLabel: UILabel!
    @IBOutlet weak var imageView: UIImageView!
    
    override func viewWillAppear(animated: Bool) {
        self.nameLabel.text = city?.name
        self.imageView.image = city?.image
    }
}
\end{swiftcode}

Betätigt ihr nun nach einem \emph{Build \& Run} den Button, wird die Content View des City Detail View Controller angezeigt und mit dem entsprechenden \swiftinline{City} Objekt konfiguriert \abbref{img:one_city_run}.

\includegraphicsc[\iphonewidth]{img/one_city_run.png}{img:one_city_run}{Wird der Button betätigt, zeigt der City Detail View Controller die Informationen zu der ausgewählten Stadt}

\item Nun fehlt nur noch die Implementierung des \emph{Zurück} Buttons. Hier verwenden wir das Konzept der \emph{Unwind Segue}, um zu einem View Controller in der View Controller Hierarchie zurückzukehren. Dazu fügen wir dem \strong{präsentierenden} View Controller (nicht dem präsentierten) eine Methode \swiftinline{unwindToCities:} nach dem im Skript beschriebenen Muster hinzu, sodass sie im Interface Builder zur Verfügung steht.

\begin{swiftcode}
// CitiesViewController.swift
import UIKit

class CitiesViewController: UIViewController {
    // ...
    @IBAction func unwindToCities(segue: UIStoryboardSegue) {
        // no implementation necessary
    }
}
\end{swiftcode}

\item Im Storyboard können wir nun das \swiftinline{UIControlEvent.TouchUpInside} Event des \emph{Zurück} Buttons mit der Unwind Segue verbinden. Zieht dazu bei gehaltener \keys{\ctrl}-Taste eine Verbindung vom Button zur \emph{Exit} Schaltfläche des City Detail View Controllers (also des \strong{präsentierten} View Controllers) \abbref{img:cities_unwind_segue}. Da ein View Controller in der View Controller Hierarchie eine Unwind Segue \swiftinline{unwindToCities:} implementiert, könnt ihr diese hier auswählen.

\includegraphicsc[\iphonewidth]{img/cities_unwind_segue.png}{img:cities_unwind_segue}{Die \emph{Exit} Schaltfläche präsentiert alle Unwind Segues in der View Controller Hierarchie}

Führt ihr die App nun aus und betätigt den \emph{Zurück} Button, so wird die Unwind Segue zum Cities View Controller ausgeführt und damit der City Detail View Controller wieder ausgeblendet.

\end{enumerate}

\begin{exc}
\begin{excitem}{cities}{Cities}{2+1}

Implementiert diesen ersten Teil der Cities App, indem ihr die Schritte oben nachvollzieht.

\strong{Bonus [+1]:} Sichert das Projekt regelmäßig durch Commits in einem Git Repository und stellt es auf GitHub zur Verfügung.

\end{excitem}
\end{exc}


\end{lecture}



\begin{lecture}


\section{One City Navigation}

Eine solche Master-Detail View Controller Hierarchie, wie wir sie in \autoref{sec:one_city} implementiert haben, ist ein so häufig verwendetes Konzept, dass \swiftinline{UIKit} dafür die Subklasse \objcinline{UINavigationController: UIViewController} zur Verfügung stellt. Diese wird im Skript erläutert und eignet sich an dieser Stelle besser als Modal Segues.

\begin{enumerate}

\item Zieht einfach ein \swiftinline{UINavigationController} Objekt aus der Object Library auf euer Storyboard. Dabei wird zusätzlich zu der Navigation Controller Scene automatisch eine weitere View Controller Scene als Root View Controller des Navigation Controllers hinzugefügt. Löscht diesen zusätzlichen View Controller und wählt stattdessen den \swiftinline{CitiesViewController} als Root View Controller. Erstellt dafür eine \emph{Relationship Segue} zwischen beiden Objekten, indem ihr wieder mit gedrückter \keys{\ctrl}-Taste eine Verbindung zieht. Markiert außerdem den Navigation Controller als Initial View Controller \abbref{img:nav_controller_segue}.

\includegraphicsc{img/nav_controller_segue.png}{img:nav_controller_segue}{Eine Relationship Segue markiert den Root View Controller eines Navigation Controllers}

\item Ihr könnt nun die Segue zwischen \swiftinline{CitiesViewController} und \swiftinline{CityDetailViewController} auswählen und im Attributes Inspector sicherstellen, dass der Typ \emph{Show} ausgewählt ist. Wenn die Segue ausgelöst wird fängt dann der in der View Controller Hierarchie übergeordnete \swiftinline{UINavigationController} die Präsentation des \swiftinline{CityDetailViewController} ab.

\item Den \emph{Zurück} Button könnt ihr nun entfernen, da \swiftinline{UINavigationController} einen eigenen Mechanismus implementiert und eine \swiftinline{UINavigationBar} am oberen Bildschirmrand anzeigt. Auch die Labels werden nicht mehr benötigt. Stattdessen können wir das \swiftinline{title: String} Attribut von \swiftinline{UIViewController} verwenden, dessen Wert als Titel in der Navigation Bar angezeigt wird \abbref{img:nav_controller_ui}.

\includegraphicsc{img/nav_controller_ui.png}{img:nav_controller_ui}{Navigation Controller zeigen eine Navigation Bar an}

\begin{swiftcode}
// CityDetailViewController.swift
import UIKit

class CityDetailViewController: UIViewController {
    var city: City?

    @IBOutlet weak var imageView: UIImageView!
    
    override func viewWillAppear(animated: Bool) {
        self.title = city?.name
        self.imageView.image = city?.image
    }
}
\end{swiftcode}

\item Da wir den Initial View Controller und damit den Root View Controller des Window Objekts verändert haben, müssen wir noch kurz die Implementierung des App Delegates anpassen, um das City Objekt korrekt weiterzugeben:

\begin{swiftcode}
// AppDelegate.swift > application:didFinishLaunchingWithOptions:
let melbourne = City(name: "Melbourne", image: UIImage(named: "melbourne"))
if let citiesViewController = (window?.rootViewController as? UINavigationController)?.topViewController as? CitiesViewController {
    citiesViewController.city = melbourne
}
\end{swiftcode}

\item Durch die Verwendung des Navigation Controllers erhält unsere App nun die Standardanimationen und -mechanismen aus \swiftinline{UIKit} \abbref{img:nav_controller_run}, die sich bspw. durch die Verwendung von Subklassen und Implementierung von Delegate-Protokollen vielseitig anpassen lassen. \\
	\swiftinline{UIKit} stellt noch weitere View Controller Container wie \swiftinline{UITabBarController} und \swiftinline{UISplitViewController} zur Verfügung, die nach einem ähnlichen Prinzip funktionieren, sowie eine vielseitige API zur Implementierung eigener View Controller Container.

\includegraphicsc[\iphonewidth]{img/nav_controller_run.png}{img:nav_controller_run}{Navigation Controller stellen Standardanimationen und -mechanismen zur Verfügung}

\end{enumerate}


\section{More Cities}

Wenn wir eine Liste von Objekten darstellen wollen, konfigurieren wir natürlich nicht explizit Views für jedes Objekt. Stattdessen verwenden wir Subklassen von \swiftinline{UITableViewController: UIViewController} und ihre Content Views der Klasse \swiftinline{UITableView: UIView}, die mit dem \emph{Delegate Konzept} vielseitig einsetzbar sind.

\skriptref{Das Delegate Konzept, Table Views \& Table View Controller}

\begin{enumerate}

\item Wir möchten nun eine Liste von Städten anstatt einzelner Buttons anzeigen. Dafür ändern wir die Superklasse unseres \swiftinline{CitiesViewController} von \swiftinline{UIViewController} zu \swiftinline{UITableViewController}. Außerdem können wir die IBOutlet Referenz zu dem \emph{cityButton} entfernen.

\item Ein Table View Controller hat ein Objekt der \swiftinline{UITableView} Klasse als Content View. Im Storyboard müssen wir daher die bisherige Content View mit einem Table View Objekt aus der Object Library ersetzen. Die Content View wird ersetzt, wenn wir die neue View einfach auf das View Controller Objekt in der Document Outline links ziehen.

\strong{Hinweis:} Anstatt einen existierenden View Controller wie beschrieben in einen Table View Controller umzukonfigurieren, kann auch ein Table View Controller aus der Object Library gezogen werden. Dieser hat dann bereits eine \swiftinline{UITableView} als Content View.

\item Eine Table View kann, wie im Skript beschrieben, dynamischen oder statischen Inhalt darstellen. Im Attributes Inspector können wir den Modus \emph{Dynamic Properties} auswählen. Damit die Table View nun Inhalt präsentieren kann, benötigt sie \emph{Prototype Cells}, die den "{}Bauplan"{} für jede Zelle dieser Art definieren. Fügt dafür eine \swiftinline{UITableViewCell} aus der Object Library hinzu oder erhöht die entsprechende Zahl im Attributes Inspector um 1.

\item Wir können Prototype Cells nun entweder nach Belieben mit Subviews konfigurieren, oder im Attributes Inspector einen Standardstil auswählen. Wählt hier zunächst einfach \emph{Basic} \abbref{img:morecities_prototypecells}.

\includegraphicsc[\iphonewidth]{img/morecities_prototypecells.png}{img:morecities_prototypecells}{Prototype Cells dienen als Vorlage für die Zellen der Table View}

\item Um Prototype Cells zu identifizieren, sollte ihnen ein \emph{Reuse Identifier} im Attributes Inspector zugeordnet werden. Tippt hier \str{cityCell} ein. Wie im Skript erklärt kann die Table View damit Zellen, die gerade nicht angezeigt werden, an anderer Stelle wiederverwenden.

\item Da unsere Table View dynamischen Inhalt anzeigen soll, können wir diesen nicht im Storyboard konfigurieren. Stattdessen verwendet die Table View das \emph{Delegate Kozept}, um Daten zu "{}erfragen"{}, wenn sie sie benötigt. Dazu ruft das \swiftinline{UITableView} Objekt Methoden auf einem Delegate Objekt auf, die in einem \emph{Protokoll} definiert sind. \swiftinline{UITableView} teilt diese Anfragen in die \swiftinline{UITableViewDatasource} und \swiftinline{UITableViewDelegate} Protokolle auf. Um den entsprechenden Attributen \swiftinline{datasource: UITableViewDatasource} und \objcinline{delegate: UITableViewDelegate} Objekte zuzuweisen, sind diese als IBOutlets markiert. Zieht also zwei Verbindungen von der Table View zum \swiftinline{CitiesViewController} und wählt diesen damit sowohl als Delegate als auch als Datasource.

\item Häufig repräsentiert eine Table View ein Array, wie hier eine Liste von Städten. Definiert also im öffentlichen Interface des \swiftinline{CitiesViewController} ein Attribut \swiftinline{cities: [City]?} anstatt des bisherigen \swiftinline{city: City?} Attributs.

Passt außerdem erneut die Implementierung des App Delegates an, um diesem Attribut nun eine Liste von Städten zuzuweisen:

\begin{swiftcode}
// AppDelegate.swift
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
    let melbourne = City(name: "Melbourne", image: UIImage(named: "melbourne"))
    let sydney = City(name: "Sydney", image: UIImage(named: "sydney"))
    if let citiesViewController = (window?.rootViewController as? UINavigationController)?.topViewController as? CitiesViewController {
        citiesViewController.cities = [ melbourne, sydney ]
    }
    return true
}
\end{swiftcode}

\item Als Subklasse von \swiftinline{UITableViewController} erbt \swiftinline{CitiesViewController} leere Implementierungen der \swiftinline{UITableViewDatasource} und \swiftinline{UITableViewDelegate} Protokolle. Wir können diese nun überschreiben, um unsere Tabelle mit Daten zu füllen. Dabei sind zunächst die drei erforderlichen Methoden zur Darstellung einer dynamischen Table View zu implementieren:

\begin{swiftcode}
// ViewController.swift
import UIKit

class CitiesViewController: UITableViewController {
    var cities: [City]?
    
    override func numberOfSectionsInTableView(tableView: UITableView) -> Int {
        return 1
    }
    override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return cities?.count ?? 0
    }
    override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {
        let city = cities![indexPath.row]
        let cell = tableView.dequeueReusableCellWithIdentifier("cityCell", forIndexPath: indexPath) as! UITableViewCell
        cell.textLabel?.text = city.name
        cell.imageView?.image = city.image
        return cell
    }
    
    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
        if let indexPath = self.tableView.indexPathForSelectedRow() {
            let city = cities![indexPath.row]
            if let identifier = segue.identifier {
                switch identifier {
                case "showCityDetail":
                    if let cityDetailViewController = segue.destinationViewController as? CityDetailViewController {
                        cityDetailViewController.city = city
                    }
                default:
                    break
                }
            }
        }
    }
}
\end{swiftcode}

\item Diese drei Methoden des \swiftinline{UITableViewDatasource} Protokolls stellen der Table View die erforderlichen Informationen zur Verfügung, um die Tabelle anzeigen zu können \abbref{img:cities_tableview}.

\includegraphicsc[\iphonewidth]{img/cities_tableview.png}{img:cities_tableview}{Eine Table View stellt Anfragen an ihr Datasource und Delegate Objekt, um Zellen dynamisch anzuzeigen}

\item Die Präsentation des Detail City View Controllers kann nun erneut mithilfe von Segues realisiert werden. Dazu können wir im Storyboard eine Show Segue von der Prototype Cell zum Detail City View Controller erstellen und ihr erneut den Identifier \str{showCityDetail} geben.

\item Da diese Segue nun von jeder Zelle ausgelöst wird, die nach Vorlage der Prototype Cell erstellt wurde, müssen wir in der \swiftinline{prepareForSegue:sender:} Methode wie im Codebeispiel oben zunächst den Index Path der betätigten Zelle herausfinden. Damit lässt sich anschließend das entsprechende Model Objekt erhalten und der City Detail View Controller konfigurieren.

\item Wird nun eine Stadt in der Liste ausgewählt, wird der City Detail View Controller entsprechend konfiguriert und angezeigt. Beachtet, dass wir an dessen Implementierung nichts geändert haben!

\end{enumerate}

\begin{exc}

\begin{excitem}{tableviews}{More Cities}{2}

Implementiert die Cities App nun vollständig, indem ihr die Schritte oben nachvollzieht.

\end{excitem}

\end{exc}


\end{lecture}



\begin{lecture}


\chapter{Seasonizer}

Mit den Apps der vergangenen Vorlesungen haben wir die Grundlagen der Programmierung für iOS Geräte und einige wichtige Architekturkonzepte kennengelernt. Mit diesem Wissen lässt sich bereits ein Großteil der zur Verfügung stehenden Frameworks anwenden und viele Funktionen, die iOS Geräte bieten, in unsere eigenen Apps integrieren.

%Aus gegebenem Anlass implementieren wir in dieser App einige häufig verwendete Funktionen wie Multi-Touch Gesten und Kamera Integration, um beim nächsten Familienfest nicht nur mit unseren neu erworbenen Programmierfähigkeiten anzugeben, sondern auch noch Fotos von Familienmitgliedern festlich dekorieren zu können \abbref{img:seasonizer}.

Zusammenfassend implementieren wir in dieser App einige häufig verwendete Funktionen wie Multi-Touch Gesten und Kamera Integration, um beim nächsten Familienurlaub nicht nur mit unseren neu erworbenen Programmierfähigkeiten anzugeben, sondern auch noch Fotos von Familienmitgliedern sommerlich dekorieren zu können \abbref{img:seasonizer}.

\includegraphicsc[\iphonewidth]{img/seasonizer_summer.png}{img:seasonizer}{Mit der Seasonizer App lassen sich Freunde und Familienmitglieder sommerlich dekorieren.}

\subsubsection{Funktionen der Seasonizer App [4++~P.]}

\begin{itemize}
	\item Die App besitzt eine Hauptansicht mit Navigation Bar und Toolbar. Den Inhalt füllt eine Image View für das Foto und eine darüberliegende View mit transparentem Hintergrund für die Accessories. [1~P.]
	\item Es gibt einen Button in der Toolbar, mit dem ein Foto von der Kamera oder Foto Bibliothek ausgewählt werden kann, das anschließend von der Image View angezeigt wird. [1~P.]
	\item Ein weiterer Button zeigt modal eine Liste von Accessories an. Wird ein Accessory ausgewählt, wird es der Hauptansicht hinzugefügt. [1~P.]
	\item Die Accessories lassen sich mit Gesten verschieben, skalieren, drehen und löschen. [1~P.]
	\item Mit einem Action Button kann das Bild über verschiedene Kanäle wie Nachrichten, Email oder Facebook verteilt werden. [1~P.]
	\item Die Elemente wie Bild und Accessories werden gespeichert und beim nächsten Start der App wiederhergestellt. [1~P.]
	\item Ein Toolbar Button dient dem Zurücksetzen der Benutzeroberfläche. [1~P.]
	%\item [extra] Es schneit in der App!
	\item Implementiert, was euch einfällt! Ich bin auf eure Ideen gespannt. [++~P.]
\end{itemize}

Anders als für die bisherigen Apps wird es an dieser Stelle keine vollständige Schritt-für-Schritt Anleitung geben. Versucht stattdessen, die Funktionen der App zu implementieren, indem ihr die folgenden Hinweise und die Informationen der bisherigen Themen anwendet. Ich stehe dabei natürlich jederzeit gerne für Fragen zur Verfügung.

\subsubsection{Hinweise}

\begin{itemize}

\item Wenn ihr mit dem \emph{Single View} Template beginnt, bietet es sich an, dem View Controller der Hauptansicht zunächst einen sinnvollen Namen wie \swiftinline{CanvasViewController} zu geben. Verwendet außerdem den Project Name \str{Seasonizer}.

\item \strong{Navigation Bar und Toolbar} lassen sich sehr einfach anzeigen, wenn ein Navigation Controller verwendet wird. Dieser besitzt ein Attribut \emph{Shows Toolbar}, das im Interface Builder aktiviert werden kann. Buttons lassen sich dann als Objekte der \swiftinline{UIBarButtonItem} Klasse aus der Object Library einem Navigation Item hinzufügen. \swiftinline{UIBarButtonItem} bietet bereits viele Stile wie \swiftinline{UIBarButtonSystemItemCamera} zur Auswahl im Attributes Inspector an.

\item Die Auswahl zwischen \strong{Kamera und Foto Bibliothek} lässt sich sinnvoll mit einem \swiftinline{UIAlertController} implementieren. Den Zugriff auf Kamera oder Foto Bibliothek übernimmt dann ein entsprechend konfigurierter \swiftinline{UIImagePickerController} aus \swiftinline{UIKit}.

\begin{swiftcode}
    @IBAction func cameraButtonPressed(sender: AnyObject) {
        let alertController = UIAlertController(title: nil, message: nil, preferredStyle: .ActionSheet)
        if UIImagePickerController.isSourceTypeAvailable(.Camera) {
            alertController.addAction(UIAlertAction(title: "Take Photo", style: .Default, handler: { action in
                self.presentImagePickerWithSourceType(.Camera)
            }))
        }
        if UIImagePickerController.isSourceTypeAvailable(.PhotoLibrary) {
            alertController.addAction(UIAlertAction(title: "Choose from Photo Library", style: .Default, handler: { action in
                self.presentImagePickerWithSourceType(.PhotoLibrary)
            }))
        }
        alertController.addAction(UIAlertAction(title: "Cancel", style: .Cancel, handler: nil))
        self.presentViewController(alertController, animated: true, completion: nil)
    }
    func presentImagePickerWithSourceType(sourceType: UIImagePickerControllerSourceType) {
        let imagePicker = UIImagePickerController()
        imagePicker.sourceType = sourceType
        imagePicker.delegate = self
        self.presentViewController(imagePicker, animated: true, completion: nil)
    }
\end{swiftcode}

\item Der \swiftinline{UIImagePickerController} verwendet das Delegate Konzept um die Auswahl eines Fotos zu kommunizieren. Wir setzen den View Controller selbst als Delegate, also muss dieser das \swiftinline{UIImagePickerControllerDelegate} implementieren:

\begin{swiftcode}
class CanvasViewController: UIViewController, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
    // ...
    func imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [NSObject : AnyObject]) {
        self.photoImageView.image = info[UIImagePickerControllerOriginalImage] as? UIImage
        picker.dismissViewControllerAnimated(true, completion: nil)
    }
    func imagePickerControllerDidCancel(picker: UIImagePickerController) {
        picker.dismissViewControllerAnimated(true, completion: nil)
    }
\end{swiftcode}

\item Wir modellieren die Accessories in dieser App als \swiftinline{struct Accessory}. Accessories besitzen jeweils ein Bild einen Titel. Erstellt eine Liste von Accessories im App Delegate und gebt diese Liste durch die View Controller Hierarchie weiter an den \swiftinline{CanvasViewController}.

\item Um modal einen weiteren View Controller mit Titelleiste für die \strong{Accessory Liste} anzuzeigen, kann dieser wiederum in einem Navigation Controller verpackt werden \abbref{img:seasonizer_ui}. Es sollte eine dynamische Table View in einer Subklasse \swiftinline{AccessoryListViewController: UITableViewController} verwendet werden, um die Liste der verfügbaren Accessories anzuzeigen.

\includegraphicsc{img/seasonizer_ui.png}{img:seasonizer_ui}{Navigation Controller bieten eine einfache Möglichkeit, Navigationsleisten und Toolbars anzuzeigen}

\item Der \swiftinline{AccessoryListViewController} benötigt eine Liste von Accessories, die er präsentieren soll, sowie eine Möglichkeit, das ausgewählte Accessory wiederum dem präsentierenden View Controller zu kommunizieren. Dazu könnt ihr entweder ein eigenes Delegate Protokoll implementieren, oder Unwind Segues verwenden. Im Skript findet ihr ein Beispiel für die Implementierung eines Delegate Protokolls. Wenn ihr lieber Unwind Segues verwenden möchtet, müsst ihr die Liste von Accessories zunächst in der \swiftinline{prepareForSegue:} Methode weitergeben und dann das ausgewählt Accessory in der Unwind Methode, bspw. \swiftinline{unwindToCanvas:}, auslesen.

\item Wenn der \swiftinline{CanvasViewController} nun ein \swiftinline{Accessory} bekommt, soll es durch eine View repräsentiert werden, die auf einer transparenten View \swiftinline{accessoryOverlayView} über dem Bild angezeigt wird. Erstellt dafür zunächst eine Subklasse \swiftinline{AccessoryView: UIImageView}:
\begin{swiftcode}
// AccessoryView.swift
import UIKit

class AccessoryView: UIImageView {    
    init(accessory: Accessory) {
        super.init(image: accessory.image)
    }
    required init(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}	
\end{swiftcode}

	Diese könnt ihr dann verwenden, um eine Repräsentation des ausgewählten Accessory zu erstellen:
\begin{swiftcode}
        let accessoryView = AccessoryView(accessory: accessory)
        accessoryView.center = accessoryOverlayView.convertPoint(accessoryOverlayView.center, fromView: accessoryOverlayView.superview)
        self.addAccessoryView(accessoryView) // muss noch implementiert werden
\end{swiftcode}

\item Den Code zum Hinzufügen der Accessory View zur View Hierarchie lagern wir in eine Methode \swiftinline{addAccessoryView:} aus, in der wir die View zunächst konfigurieren können.

Für die Manipulation der Accessories mit Gesten können wir \strong{Gesture Recognizer} verwenden. UIKit implementiert einige hilfreiche Subklassen von \swiftinline{UIGestureRecognizer}, die bestimmt Multi-Touch Events auf der ihr zugewiesenen View erkennen und ihr Delegate Objekt darüber informieren. Also können wir den Canvas View Controller als Empfänger des \swiftinline{UIGestureRecognizerDelegate} Protokolls markieren, Gesture Recognizer in der \swiftinline{addAccessory:} Methode hinzufügen und die Delegate Methoden zum Bewegen, Skalieren, Rotieren und Löschen der Accessories implementieren.

\begin{swiftcode}
    func addAccessoryView(accessoryView: AccessoryView) {
        self.accessoryOverlayView.addSubview(accessoryView)
        accessoryView.userInteractionEnabled = true
        // Bewegen
        let panGR = UIPanGestureRecognizer(target:self, action:"pan:")
        panGR.delegate = self
        accessoryView.addGestureRecognizer(panGR)
        // Skalieren
        let pinchGR = UIPinchGestureRecognizer(target:self, action:"pinch:")
        pinchGR.delegate = self
        accessoryView.addGestureRecognizer(pinchGR)
        // Drehen
        let rotateGR = UIRotationGestureRecognizer(target:self, action:"rotate:")
        rotateGR.delegate = self
        accessoryView.addGestureRecognizer(rotateGR)
        // Löschen
        let tapGR = UILongPressGestureRecognizer(target:self, action:"tap:")
        tapGR.delegate = self
        accessoryView.addGestureRecognizer(tapGR)
    }
    
    func gestureRecognizer(gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWithGestureRecognizer otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return true // Gesture Recognizer unterbrechen andernfalls die Erkennung einer Geste bei der Erkennung einer anderen
    }
    
    func pan(sender: UIPanGestureRecognizer) {
        if let accessoryView = sender.view {
            accessoryView.superview?.bringSubviewToFront(accessoryView)
            let translation = sender.translationInView(accessoryView.superview!)
            accessoryView.center = CGPoint(x: accessoryView.center.x + translation.x, y: accessoryView.center.y + translation.y)
            sender.setTranslation(CGPointZero, inView: accessoryView.superview!)
        }
    }
    func pinch(sender: UIPinchGestureRecognizer) {
        if let accessoryView = sender.view {
            accessoryView.superview?.bringSubviewToFront(accessoryView)
            accessoryView.transform = CGAffineTransformScale(accessoryView.transform, sender.scale, sender.scale);
            sender.scale = 1
        }
    }
    func rotate(sender: UIRotationGestureRecognizer) {
        if let accessoryView = sender.view {
            accessoryView.superview?.bringSubviewToFront(accessoryView)
            accessoryView.transform = CGAffineTransformRotate(accessoryView.transform, sender.rotation);
            sender.rotation = 0
        }
    }
    private var selectedAccessoryView: UIView?
    func tap(sender: UILongPressGestureRecognizer) {
        if sender.state != .Began {
            return
        }
        if let accessoryView = sender.view {
            self.becomeFirstResponder()
            let menuController = UIMenuController.sharedMenuController()
            menuController.menuItems = [ UIMenuItem(title: "Remove", action:"removeAccessoryButtonPressed:") ]
            menuController.setTargetRect(CGRect(x: accessoryView.center.x, y: accessoryView.center.y, width: 0, height: 0), inView: accessoryView.superview!)
            menuController.setMenuVisible(true, animated: true)
            self.selectedAccessoryView = accessoryView
        }
    }
    override func canBecomeFirstResponder() -> Bool {
        return true
    }
    func removeAccessoryButtonPressed(sender: AnyObject) {
        if let accessoryView = self.selectedAccessoryView {
            accessoryView.removeFromSuperview()
        }
    }
\end{swiftcode}

Hier sei angemerkt, dass wir aufgrund des Zusammenspiels verschiedener Gesture Recognizer jeweils Delta-Bewegungen verwenden und auf die View anwenden, indem der jeweilige Gesture Recognizer bei jedem Methodenaufruf zurückgesetzt wird.

Der \swiftinline{UILongPressGestureRecognizer} zeigt einen speziellen \swiftinline{UIMenuController} zur Darstellung eines \str{Entfernen} Buttons. Damit dieser korrekt angezeigt wird, muss die \swiftinline{canBecomeFirstResponder} Methode implementiert werden.

\item Die Integration eines \strong{Activity Sheets} zum Teilen von Inhalten ist denkbar einfach. \swiftinline{UIKit} stellt dafür den \swiftinline{UIActivityViewController} zur Verfügung, der eine Liste von Datenobjekten annimmt und abhängig vom Typ der Daten eine Auswahl von Kanälen zum Teilen anzeigt. Das Bild sollte in einer Computed Property stets neu generiert werden.

\begin{swiftcode}
    @IBAction func actionButtonPressed(sender: AnyObject) {
        let activityViewController = UIActivityViewController(activityItems: [ self.renderedPicture ], applicationActivities: nil)
        self.presentViewController(activityViewController, animated: true, completion: nil)
    }
    var renderedPicture: UIImage {
        UIGraphicsBeginImageContextWithOptions(self.view.frame.size, true, 0)
        self.view.drawViewHierarchyInRect(self.view.bounds, afterScreenUpdates: true)
        let renderedPicture = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return renderedPicture
    }
\end{swiftcode}

\item Um die Benutzeroberfläche vollständig wiederherstellen zu können, müssen wir sowohl das Foto als auch die hinzugefügten Accessories speichern. Als Methode der Datenspeicherung bietet sich in dieser App das \strong{State Preservation} System an, doch auch die \strong{User Defaults} Mechanik könnte stattdessen verwendet werden.

Zur Speicherung der Accessories müssen wir in der \swiftinline{AccessoryView: UIImageView} Klasse zunächst das \swiftinline{NSCoding} Protokoll implementieren. Dieses Protokoll bietet die Möglichkeit, Objekte als \swiftinline{NSData} zu serialisieren. \swiftinline{UIImageView} implementiert dieses Protokoll bereits, speichert aber das angezeigte Bild nicht. Daher müssen wir in der Subklasse lediglich die beiden Schlüsselmethoden überschreiben:

\begin{swiftcode}
// AccessoryView.swift
import UIKit

class AccessoryView: UIImageView {
    init(accessory: Accessory) {
        super.init(image: accessory.image)
    }
    override func encodeWithCoder(aCoder: NSCoder) {
        if let image = self.image {
            aCoder.encodeObject(UIImagePNGRepresentation(image), forKey: "image")
        }
        super.encodeWithCoder(aCoder)
    }
    required init(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        if let imageData = aDecoder.decodeObjectForKey("image") as? NSData {
            self.image = UIImage(data: imageData)
        }
    }
}
\end{swiftcode}

\item Nun müssen wir das State Preservation System lediglich noch aktivieren. Dazu müssen zwei Methoden im App Delegate implementiert werden:
\begin{swiftcode}
    func application(application: UIApplication, shouldSaveApplicationState coder: NSCoder) -> Bool {
        return true
    }
    func application(application: UIApplication, shouldRestoreApplicationState coder: NSCoder) -> Bool {
        return true
    }	
\end{swiftcode}

Außerdem muss jeder View Controller, der wiederhergestellt werden soll, sowohl alle View Controller in seiner View Controller Hierarchie, einen \swiftinline{restorationIdentifier} besitzen. Dieser kann im Storyboard im Identity Inspector zugewiesen werden. Der Navigation Controller und der Canvas View Controller benötigen also einen solchen.

Schließlich muss nur noch die Wiederherstellung des Canvas View Controllers konfiguriert werden. Dies geschieht in zwei Methoden, die wir überschreiben müssen:
\begin{swiftcode}
    // in CanvasViewController.swift
    override func encodeRestorableStateWithCoder(coder: NSCoder) {
        if let photo = photoImageView.image {
            let imageData = UIImagePNGRepresentation(photo)
            coder.encodeObject(imageData, forKey: "photo")
        }
        coder.encodeObject(NSKeyedArchiver.archivedDataWithRootObject(self.accessoryViews), forKey: "accessoryViews")
        super.encodeRestorableStateWithCoder(coder)
    }
    override func decodeRestorableStateWithCoder(coder: NSCoder) {
        if let photoData = coder.decodeObjectForKey("photo") as? NSData {
            photoImageView.image = UIImage(data: photoData)
        }
        if let accessoryViewsData = coder.decodeObjectForKey("accessoryViews") as? NSData {
            let accessoryViews = NSKeyedUnarchiver.unarchiveObjectWithData(accessoryViewsData) as! [AccessoryView]
            for accessoryView in accessoryViews {
                self.addAccessoryView(accessoryView)
            }
        }
        super.decodeRestorableStateWithCoder(coder)
    }	
\end{swiftcode}

Hier verwenden wir wieder die \swiftinline{addAccessoryView:} Methode um die Accessories der View Hierarchie hinzuzufügen und die Gesture Recognizer zu erzeugen.

\item Implementieren wir einen weiteren Toolbar Button, der die Benutzeroberfläche bei Betätigung \strong{zurücksetzt}, sollte zunächst eine Schaltfläche zur Bestätigung erscheinen. Dazu eignet sich wieder ein \swiftinline{UIAlertController} im \swiftinline{.ActionSheet} Stil.

\end{itemize}


\subsubsection{Der Seasonizer auf GitHub}

Auf GitHub findet ihr eine Beispielimplementierung des Seasonizers \linkref{https://github.com/iOS-Dev-Kurs/seasonizer}, die ihr als Referenz verwenden und auch weiterentwickeln könnt.

Haltet ihr eure Änderungen für so genial oder notwendig, dass sie in mein Original Repository übernommen werden sollten, könnt ihr mir über die GitHub Webseite eine \strong{Pull Request} schicken, die mich auffordert, einen Merge mit den Änderungen durchzuführen. In dieser Form kann ein Open Source Programmierprojekt weltweit von interessierten Entwicklern weiterentwickelt werden. Und dem Seasonizer sind damit keine Grenzen gesetzt.

\end{lecture}


\end{document}
