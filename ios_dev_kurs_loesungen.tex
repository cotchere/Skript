\documentclass[parskip=half, final]{scrartcl}

\input{include/variables}
\input{include/style}
\input{include/code_listing}

\usepackage{enumitem}

\renewcommand{\doctype}{Beispiellösungen der Übungsaufgaben}
\renewcommand{\shortdoctype}{Beispiellösungen}


\begin{document}

\maketitle

\tableofcontents


\begin{lsg}


\begin{lsgitem}{fibonacci}{Fibonacci}

\begin{objclst}
int a=1; // erstes Folgenglied
int b=2; // zweites Folgenglied
int di=0; // Abstand zur letzten geraden Zahl
while ((a+b)<1000) { // die Schleife wird ausgeführt, bis die nächste Fibonaccizahl zu groß wird
    int c = a+b;
    NSLog(@"%i",c);
    a = b;
    b = c;
    di++;
    if (c%2==0) { // Ausdruck ergibt YES für gerade Zahlen
        NSLog(@"Zahl gerade, Abstand zur vorigen geraden Fibonaccizahl: %i", di);
        di = 0;
    }
}
\end{objclst}

\end{lsgitem}


\begin{lsgitem}{primenumbers}{Primzahlen}

\begin{objclst}
// prime numbers
for (int i=1; i<1000; i++) { // loop through all numbers from 1 to 1000
    BOOL isPrime = YES;
    for (int j=2; j<i-1; j++) { // check the division rest with every number from 2 up to (excluding) the current number and break when a divisor was found
        if (i%j==0) {
            isPrime = NO;
            break;
        }
    }
    if (isPrime) { // if isPrime is still YES here, no divisor was found
        NSLog(@"Prime number found: %i", i);
    }
}
\end{objclst}

\end{lsgitem}


\begin{lsgitem}{scientists}{Scientists}

\begin{enumerate}
\item In Xcode könnt ihr eine neue Klasse mit \keys{\cmdkey + N} erstellen. Nennt die Klasse \objc{Scientist} und wählt die Superklasse \objc{Person}. Die Main- und Header-Datei erscheinen nach dem Speichern im Project Navigator.
\item Im Interface in der Header-Datei wird die neue Methode zunächst definiert:

\begin{objclst}
#import "Person.h"

@interface Scientist : Person

- (void)sayPrimeNumbersUpTo:(int)number;

@end
\end{objclst}

Anschließend können wir sie in der Main-Datei implementieren:

\begin{objclst}
#import "Scientist.h"

@implementation Scientist

- (void)sayPrimeNumbersUpTo:(int)number {
    // Algorithmus aus Aufgabe 'Primzahlen'
}

@end
\end{objclst}

In der nun schon häufiger verwendeten \objc{application:didFinishLaunchingWithOptions:} Methode in der \emph{AppDelegate.m}-Datei, wollen wir die neue Klasse ausprobieren:

\begin{objclst}
#import "AppDelegate.h"

#import "Scientist.h"

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    
    Scientist *aScientist = [[Scientist alloc] init];
    [aScientist sayPrimeNumbersUpTo:100];

    return YES;
}

@end
\end{objclst}

Führen wir die App aus, werden alle Primzahlen bis 100 in der Konsole ausgegeben.

\item Mit Objekten des Typs \objc{Scientist} kann genauso verfahren werden wie mit Objekten des Typs \objc{Person}, da sie voneinander abstammen und daher alle Attribute und Methoden erben. Schreibt also in der \emph{AppDelegate.m}-Datei:

\begin{objclst}
#import "AppDelegate.h"

#import "Scientist.h"

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    
    Scientist *aScientist = [[Scientist alloc] init];
    aScientist.name = @"Alice";
    [aScientist sayHello];

    return YES;
}

@end
\end{objclst}

Es wird wieder ausgegeben:

\begin{objclst}
Hello World! My name is Alice.
\end{objclst}

\item Die \objc{Scientist}-Klasse besitzt bereits die Methode \objc{sayHello}, da sie in ihrer Superklasse \objc{Person} definiert und implementiert wird. Um sie zu überschreiben, müssen wir sie nur in der Main-Datei erneut implementieren:

\begin{objclst}
#import "Scientist.h"

@implementation Scientist

- (void)sayPrimeNumbersUpTo:(int)number {
    // Primzahlen-Algorithmus
}

- (void)sayHello {
    NSLog(@"Hello World! My name is %@. I know all Prime Numbers.", self.name);
}

@end
\end{objclst}

Nun wird statt der Methodenimplementierung in der Superklasse 'Person' diese Neuimplementierung verwendet und der zusätzliche Text wird ausgegeben, wenn die Methode \objc{sayHello} von einem Objekt der Klasse 'Scientist' aufgerufen wird:

\begin{objclst}
Hello World! My name is Alice. I am a Scientist.
\end{objclst}

Da wir der Implementierung der Superklasse im Prinzip nur etwas hinzufügen wollen, ist es eleganter, stattdessen erst diese aufzurufen und dann den zusätzlichen Code auszuführen: 

\begin{objclst}
- (void)sayHello {
    [super sayHello]; // Die Implementierung Superklasse wird aufgerufen
    NSLog(@"I know all Prime Numbers.");
}
\end{objclst}

Ausgabe:

\begin{objclst}
Hello World! My name is Alice.
I know all Prime Numbers.
\end{objclst}

\end{enumerate}

\end{lsgitem}


\begin{lsgitem}{emails}{Emails}

\begin{filecontent}{Email.h}
\begin{objclst}
@interface Email : NSObject

@property (strong, nonatomic) NSMutableArray *allRecipients;

- (void)sendTo:(NSArray *)recipients;

@end
\end{objclst}
\end{filecontent}

\begin{filecontent}{Email.m}
\begin{objclst}
#import "Email.h"
#import "Person.h"

@implementation Email

- (void)sendTo:(NSArray *)recipients {
    for (Person *person in recipients) {
        // treat email as spam and skip if it has already been sent to this person before
        if ([self.allRecipients containsObject:person]) continue;
        // add person to list of all recipients
        if (!self.allRecipients) self.allRecipients = [[NSMutableArray alloc] init];
        [self.allRecipients addObject:person];
        // deliver email
        [person receiveEmail:self];
     }
}

@end
\end{objclst}
\end{filecontent}

\begin{filecontent}{Person.h}
\begin{objclst}
@class Email; // Forward Declaration

@interface Person : NSObject

@property (strong, nonatomic) NSString *name;

- (void)makeFriendsWith:(Person *)person;

- (void)sendEmail;
- (void)receiveEmail:(Email *)email;

@end
\end{objclst}
\end{filecontent}

\begin{filecontent}{Person.m}
\begin{objclst}
#import "Person.h"
#import "Email.h"

@interface Person () // private interface

@property (strong, nonatomic) NSMutableArray *friends;

@end

@implementation Person

- (void)makeFriendsWith:(Person *)person {
    // make sure to skip connection if already existent or redundant
    if (!person||person==self||[self.friends containsObject:person]) return;
    // create friends array if not existent yet and add person
    if (!self.friends) self.friends = [[NSMutableArray alloc] init];
    [self.friends addObject:person];
    // trigger reverse connection
    [person makeFriendsWith:self];
    NSLog(@"%@ <-> %@", self.name, person.name);
}

- (void)sendEmail {
    Email *newEmail = [[Email alloc] init];
    [newEmail sendTo:self.friends];
}

- (void)receiveEmail:(Email *)email {
    NSLog(@"%@ received an Email.", self.name);
    [email sendTo:self.friends];
}

@end
\end{objclst}
\end{filecontent}

\begin{filecontent}{AppDelegate.m}
\begin{objclst}
#import "AppDelegate.h"
#import "Person.h"

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {

    Person *me = [[Person alloc] init];
    me.name = @"Nils";

    NSMutableArray *persons = [[NSMutableArray alloc] init];

    NSArray *names = @[@"Alice", @"Bob", @"Cindy", @"Bruce", @"Chris", @"Bill ", @"Susan"];
    for (NSString *name in names) {
        Person *newPerson = [[Person alloc] init];
        newPerson.name = name;

        [persons addObject:newPerson];
        [me makeFriendsWith:newPerson];
    }

    // befriend persons with same initial letter
    for (Person *person in persons) {
        for (Person *other in persons) {
            if ([person.name characterAtIndex:0]==[other.name characterAtIndex:0]) {
                [person makeFriendsWith:other];
            }
        }
    }

    // start simulation
    [me sendEmail];

    return YES;
}

@end
\end{objclst}
\end{filecontent}

\end{lsgitem}


\begin{lsgitem}{scientists2}{Scientists 2}

Die Methode \objc{sayHello} muss nicht mehr implementiert werden, denn eine Überschreibung der Superklassenimplementierung ist nicht mehr notwendig. Diese ruft nämlich nur die Methode \objc{helloString} auf und gibt den Rückgabewert in der Konsole aus. Stattdessen müssen wir also \objc{helloString} überschreiben, damit der Zusatz \emph{I know all Prime Numbers.} ausgegeben wird:

\begin{objclst}
- (NSString *)helloString {
    NSString *greeting = [super helloString];
    greeting = [greeting stringByAppendingString:@" I am a Scientist."];
    return greeting;
}
\end{objclst}

Oder in Kurzform:

\begin{objclst}
- (NSString *)helloString {
    return [[super helloString] stringByAppendingString:@" I am a Scientist."];;
}
\end{objclst}

\end{lsgitem}

\begin{lsgitem}{simpleui}{Simple UI}

\subsection{Counter App}

\begin{enumerate}
\item Erstellen wir zunächst das User Interface. Wählt eine der Storyboard-Dateien im Project Navigator, entsprechend des Geräts, für das ihr das UI konfigurieren möchtet.
\item Zieht zwei Labels und drei Buttons aus der Object Library unten im Inspektor in die erste und einzige Scene und konfiguriert sie mit dem Inspektor \abbref{img:counter_ui}.
\includegraphicsc[.4\textwidth]{img/counter_ui.png}{img:counter_ui}{Einige Labels und Buttons sind für diese einfache App ausreichend}
\item Wechselt in den Assistant-Editor, sodass die Datei \emph{ViewController.m} rechts angezeigt wird. Wählt diese wenn nötig in der Jump bar des Assistant-Editors unter \menu{Automatic} aus.
\item Definiert eine Property im privaten Interface, die zur Laufzeit der App die Referenz zum Label hält. Zusätzlich kann hier direkt die Property \objc{int count} definiert werden, da diese ebenfalls nicht öffentlich sein muss. Definiert außerdem die benötigten Methoden:
\begin{objclst}
@interface ViewController ()

@property (nonatomic) int count;

@property (strong, nonatomic) IBOutlet UILabel *countLabel;

- (void)updateLabel;

- (IBAction)increaseButtonPressed:(id)sender;
- (IBAction)decreaseButtonPressed:(id)sender;
- (IBAction)resetButtonPressed:(id)sender;

@end
\end{objclst}
\item Zieht mit gedrückter \keys{\ctrlkey}-Taste eine Verbindung zwischen Label und Property, sowie zwischen Buttons und Methoden.
\item Implementiert die Methoden in der Main-Datei:
\begin{objclst}
- (void)updateLabel {
    self.countLabel.text = [NSString stringWithFormat:@"%i", self.count];
}

- (IBAction)increaseButtonPressed:(id)sender {
    self.count++;
    [self updateLabel];
}
- (IBAction)decreaseButtonPressed:(id)sender {
    self.count--;
    [self updateLabel];
}
- (void)resetButtonPressed:(id)sender {
    self.count = 0;
    [self updateLabel];
}
\end{objclst}
\item Build \& Run !
\end{enumerate}

\subsection{BMI App}

Analog zur Counter App erstellen wir ein neues Projekt und konfigurieren das User Interface im Storyboard \abbref{img:bmi_ui}.

\includegraphicsc[.4\textwidth]{img/bmi_ui.png}{img:bmi_ui}{Achtet bei der UI Gestaltung darauf, dass die Interfaceelemente nicht von der erscheinenden Tastatur verdeckt werden}

\begin{filecontent}{ViewController.m}
\begin{objclst}
#import "ViewController.h"

@interface ViewController ()

@property (strong, nonatomic) IBOutlet UITextField *gewichtTextfield;
@property (strong, nonatomic) IBOutlet UITextField *groesseTextfield;
@property (strong, nonatomic) IBOutlet UILabel *bmiLabel;

- (IBAction)berechneButtonPressed:(id)sender;

@end

@implementation ViewController

- (IBAction)berechneButtonPressed:(id)sender {
    float m = [self.gewichtTextfield.text floatValue];
    float l = [self.groesseTextfield.text floatValue];
    float bmi = m/l/l;
    self.bmiLabel.text = [NSString stringWithFormat:@"%.1f", bmi];
}

@end
\end{objclst}
\end{filecontent}

\subsection{RGB App}

\includegraphicsc[.4\textwidth]{img/rgb_ui.png}{img:rgb_ui}{Die RGB App zeigt Eingabefelder für die Farbkomponenten der Hintergrundfarbe}

\begin{filecontent}{ViewController.m}
\begin{objclst}
#import "ViewController.h"

@interface ViewController ()

@property (strong, nonatomic) IBOutlet UITextField *rTextfield;
@property (strong, nonatomic) IBOutlet UITextField *gTextfield;
@property (strong, nonatomic) IBOutlet UITextField *bTextfield;

@property (strong, nonatomic) NSTimer *randomTimer;

- (IBAction)farbeAnzeigenButtonPressed:(id)sender;
- (IBAction)randomButtonPressed:(id)sender;
- (IBAction)switchValueChanged:(UISwitch *)sender;

@end

@implementation ViewController

- (IBAction)farbeAnzeigenButtonPressed:(id)sender {
    float r = [self.rTextfield.text floatValue];
    float g = [self.gTextfield.text floatValue];
    float b = [self.bTextfield.text floatValue];
    self.view.backgroundColor = [UIColor colorWithRed:r/255. green:g/255. blue:b/255. alpha:1.];
}

- (IBAction)randomButtonPressed:(id)sender {
    self.rTextfield.text = [NSString stringWithFormat:@"%i", arc4random_uniform(256)];
    self.gTextfield.text = [NSString stringWithFormat:@"%i", arc4random_uniform(256)];
    self.bTextfield.text = [NSString stringWithFormat:@"%i", arc4random_uniform(256)];
    [self farbeAnzeigenButtonPressed:sender];
}

- (IBAction)switchValueChanged:(UISwitch *)sender {
    if (sender.isOn) {
        self.randomTimer = [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(randomButtonPressed:) userInfo:nil repeats:YES];
    } else {
        [self.randomTimer invalidate];
        self.randomTimer = nil;
    }
}
\end{objclst}
\end{filecontent}

\end{lsgitem}


\setcounter{section}{7} % Chatter


\begin{lsgitem}{view_hierarchie}{View Hierarchie}

Als Beispiel ist hier die RGB App implementiert:

\begin{filecontent}{AppDelegate.m}
\begin{objclst}
#import "AppDelegate.h"

@interface AppDelegate ()

@property (strong, nonatomic) UITextField *rTextfield;
@property (strong, nonatomic) UITextField *gTextfield;
@property (strong, nonatomic) UITextField *bTextfield;

@property (strong, nonatomic) NSTimer *randomTimer;

- (void)farbeAnzeigenButtonPressed:(id)sender;
- (void)randomButtonPressed:(id)sender;
- (void)switchValueChanged:(UISwitch *)sender;

@end

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {

    // create and display the window

    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    self.window.backgroundColor = [UIColor whiteColor];
    [self.window makeKeyAndVisible];

    // create textfields and buttons and add to view hirachy

    self.rTextfield = [[UITextField alloc] initWithFrame:CGRectMake(20, 50, 66, 44)];
    [self.window addSubview:self.rTextfield];
    self.rTextfield.placeholder = @"Red";

    self.gTextfield = [[UITextField alloc] initWithFrame:CGRectOffset(self.rTextfield.frame, self.rTextfield.frame.size.width+20, 0)];
    [self.window addSubview:self.gTextfield];
    self.gTextfield.placeholder = @"Green";

    self.bTextfield = [[UITextField alloc] initWithFrame:CGRectOffset(self.gTextfield.frame, self.rTextfield.frame.size.width+20, 0)];
    [self.window addSubview:self.bTextfield];
    self.bTextfield.placeholder = @"Blue";

    UIButton *farbeAnzeigenButton = [[UIButton alloc] initWithFrame:CGRectMake(20, self.rTextfield.frame.origin.y+self.rTextfield.frame.size.height+20, 280, 44)];
    [self.window addSubview:farbeAnzeigenButton];
    [farbeAnzeigenButton setTitle:@"Farbe anzeigen" forState:UIControlStateNormal];
    [farbeAnzeigenButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
    [farbeAnzeigenButton addTarget:self action:@selector(farbeAnzeigenButtonPressed:) forControlEvents:UIControlEventTouchUpInside]; // the equivalent to an IBAction

    UIButton *randomButton = [[UIButton alloc] initWithFrame:CGRectOffset(farbeAnzeigenButton.frame, 0, farbeAnzeigenButton.frame.size.height+20)];
    [self.window addSubview:randomButton];
    [randomButton setTitle:@"zufällig" forState:UIControlStateNormal];
    [randomButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
    [randomButton addTarget:self action:@selector(randomButtonPressed:) forControlEvents:UIControlEventTouchUpInside];

    UISwitch *rndSwitch = [[UISwitch alloc] initWithFrame:CGRectOffset(randomButton.frame, 0, randomButton.frame.size.height+20)];
    [self.window addSubview:rndSwitch];
    [rndSwitch addTarget:self action:@selector(switchValueChanged:) forControlEvents:UIControlEventValueChanged];

    return YES;
}

- (void)farbeAnzeigenButtonPressed:(id)sender {
    float r = [self.rTextfield.text floatValue];
    float g = [self.gTextfield.text floatValue];
    float b = [self.bTextfield.text floatValue];
    self.window.backgroundColor = [UIColor colorWithRed:r/255. green:g/255. blue:b/255. alpha:1.];
}

- (void)randomButtonPressed:(id)sender {
    self.rTextfield.text = [NSString stringWithFormat:@"%i", arc4random_uniform(256)];
    self.gTextfield.text = [NSString stringWithFormat:@"%i", arc4random_uniform(256)];
    self.bTextfield.text = [NSString stringWithFormat:@"%i", arc4random_uniform(256)];
    [self farbeAnzeigenButtonPressed:sender];
}

- (void)switchValueChanged:(UISwitch *)sender {
    if (sender.isOn) {
        self.randomTimer = [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(randomButtonPressed:) userInfo:nil repeats:YES];
    } else {
        [self.randomTimer invalidate];
        self.randomTimer = nil;
    }
}
\end{objclst}
\end{filecontent}

\end{lsgitem}


\begin{lsgitem}{autolayout}{Auto Layout}

Die möglichen Constraints sind in Gleichungsform oder Visual Format Syntax angegeben. \objc{contentView} bezeichnet die View an erster Stelle der Hierarchie.

\begin{enumerate}[label=\alph*)]
\item
\begin{itemize}
\item \objc{segmentedControl.centerX = contentView.centerX}
\item \objc{H:|-0-[progressView]-0-|}
\item \objc{H:|-0-[mainView]-0-|}
\item \objc{V:|-[segmentedControl]-[progressView]-[mainView]-0-|}
\end{itemize}
\item Die beiden Buttons \objc{playButton} und \objc{pauseButton} sind Subviews einer View \objc{buttonCenterView} mit transparenter Hintergrundfarbe.
\begin{itemize}
\item \objc{H:|-0-[playButton]-20-[pauseButton]-0-|}
\item \objc{playButton.centerY = pauseButton.centerY = buttonCenterView.centerY}
\end{itemize}
Die \objc{buttonCenterView} besitzt damit eine Intrinsic Content Size, die von der Größe ihrer enthaltenen Buttons bestimmt wird.
\begin{itemize}
\item \objc{buttonCenterView.centerX = contentView.centerX}
\item \objc{H:|-[volumeLabel]-[volumeSlider]-|}
\item \objc{H:|-0-[mainView]-0-|}
\item \objc{V:|-[buttonCenterView]-[volumeSlider]-[mainView]-0-|}
\item \objc{volumeLabel.centerY = volumeSlider.centerY}
\end{itemize}
\item Die Platzhalter Intrinsic Content Size von 300x300 und 100x100 kann im Attributes Inspector eingestellt werden. Zur Laufzeit wird diese verschwinden, da die Views keinen Inhalt besitzen. Es können stattdessen auch explizite \objc{height} und \objc{width} Constraints gesetzt werden, sodass die Views zur Laufzeit diese Größe erhalten. Im Allgemeinen sollte die Größe einer View jedoch von ihrer Intrinsic Content Size bestimmt werden.
\begin{itemize}
\item \objc{largeView.centerX = contentView.centerX}
\item \objc{largeView.centerY = contentView.centerY @500}
\item \objc{smallView.centerX = contentView.centerX}
\item \objc{V:|-(>=20)-[largeView]-(>=20)-[smallView]-20-|}
\item \objc{largeView.verticalCompressionResistance = 501}
\end{itemize}
\item Wir verwenden vier zusätzliche Views als Platzhalter und setzen ihr Attribut \objc{BOOL hidden} im Attributes Inspector auf \objc{YES}. Die drei zu positionierenden Views erhalten eine Platzhalter Intrinsic Content Width von 50 oder eine explizite \objc{width} Constraint.
\begin{itemize}
\item \objc{V:|-20-[view0]-20-|}
\item \objc{V:|-20-[view1]-20-|}
\item \objc{V:|-20-[view2]-20-|}
\item \objc{placeholderView0.width = placeholderView1.width = placeholderView2.width = placeholderView3.width}
\item \objc{placeholderView0.centerY = placeholderView1.centerY = placeholderView2.centerY = placeholderView3.centerY = contentView.centerY // nur notwendig, damit das Layout eindeutig ist}
\item \objc{H:|-0-[placeholderView0]-0-[view0]-0-[placeholderView1]-0-[view1]-0-[placeholderView2]-0-[view2]-0-[placeholderView3]-0-|}
\end{itemize}
\end{enumerate}

\end{lsgitem}\end{lsg}\end{document} % POINTER


\begin{lsgitem}{cities}{Cities}

Anleitung im App Katalog…

\end{lsgitem}


\begin{lsgitem}{continents}{Continents}

\begin{enumerate}

\item Eine Möglichkeit zur Implementierung der Datenstruktur besteht darin, die Klassen \objc{City} und \objc{Continent} als Subklassen von \objc{Location} zusammenzufassen und zunächst sämtliche Attribute in der Superklasse zu definieren:

\begin{objclst}
// Location.h

@interface Location : NSObject

@property (strong, nonatomic) NSString *name;
@property (strong, nonatomic) UIImage *image;

@end
\end{objclst}

\begin{objclst}
// Continent.h

#import "Location.h"

@interface Continent : Location

@end
\end{objclst}

\begin{objclst}
// City.h

#import "Location.h"

@interface City : Location

@end
\end{objclst}

\item Erstellt eine neue Klasse \objc{ContinentsViewController : UIViewController}.

Zieht ein View Controller Objekt aus der Object Library auf das Storyboard. Im Identity Inspector könnt ihr den Namen der Klasse \objc{ContinentsViewController} eintragen. Zieht anschließend einen Button auf die Content View.

Entfernt die Relationship Segue zwischen Navigation Controller und Cities View Controller und erstellt stattdessen eine solche zwischen Navigation Controller und Continents View Controller. Haltet dafür die \keys{\ctrlkey}-Taste gedrückt und zieht eine Verbindung zwischen den View Controllern. Erstellt außerdem analog eine Push Segue von dem Button zum Cities View Controller.

\item Fügt dem \objc{CitiesViewController} ein neues Attribut \objc{Continent *continent} hinzu:

\begin{objclst}
// CitiesViewController.h

@class Continent;

@interface CitiesViewController : UIViewController

@property (strong, nonatomic) Continent *continent;

@end
\end{objclst}

Nun können wir die \objc{prepareForSegue:sender} Methode des \objc{ContinentsViewController} implementieren:

\begin{objclst}
// ContinentsViewController.h

#import "ContinentsViewController.h"
#import "Continent.h"
#import "CitiesViewController.h"

@interface ContinentsViewController ()

@end

@implementation ContinentsViewController

- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
    Continent *continent = [[Continent alloc] init];
    continent.name = @"Ozeanien";
    CitiesViewController *citiesVC = segue.destinationViewController;
    citiesVC.continent = continent;
}

@end
\end{objclst}

\item In der \objc{CitiesViewController} Klasse muss nun nur noch der Titel entsprechend des Kontinenten angepasst werden.

\begin{objclst}
// CitiesViewController.m

#import "CitiesViewController.h"
#import "City.h"
#import "Continent.h"
#import "CityDetailViewController.h"

@interface CitiesViewController ()

@end

@implementation CitiesViewController

- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    self.title = self.continent.name;
}

- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
    City *city = [[City alloc] init];
    city.name = @"Melbourne";
    city.image = [UIImage imageNamed:@"melbourne"];
    CityDetailViewController *cityDetailVC = segue.destinationViewController;
    cityDetailVC.city = city;
}

@end
\end{objclst}

\item Um das neue Attribut \objc{NSArray *subLocations} der \objc{Location} Klasse zu verwenden, fügen wir zunächst beiden View Controllern im Storyboard einen weiteren Button hinzu. Außerdem verbinden wir jeweils beide Buttons mit IBOutlets im Code, damit wir diese in der \objc{prepareForSegue:sender:} Methode identifizieren können.

\begin{objclst}
// ContinentsViewController.m

#import "ContinentsViewController.h"
#import "Continent.h"
#import "City.h"
#import "ViewController.h"

@interface ContinentsViewController ()

@property (strong, nonatomic) IBOutlet UIButton *firstButton;
@property (strong, nonatomic) IBOutlet UIButton *secondButton;

@end

@implementation ContinentsViewController

- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
    Continent *continent = [[Continent alloc] init];
    City *firstCity = [[City alloc] init];
    City *secondCity = [[City alloc] init];
    if (sender==self.ozeanienButton) {
        continent.name = @"Ozeanien";
        firstCity.name = @"Melbourne";
        firstCity.image = [UIImage imageNamed:@"melbourne"];
        secondCity.name = @"Sydney";
        secondCity.image = [UIImage imageNamed:@"sydney"];
    } else if (sender==self.nordamerikaButton) {
        continent.name = @"Nordamerika";
        firstCity.name = @"San Francisco";
        firstCity.image = [UIImage imageNamed:@"sanfrancisco"];
        secondCity.name = @"Los Angeles";
        secondCity.image = [UIImage imageNamed:@"losangeles"];
    }
    continent.subLocations = @[firstCity, secondCity];
    ViewController *citiesViewController = segue.destinationViewController;
    citiesViewController.continent = continent;
}

@end
\end{objclst}

\begin{objclst}
// CitiesViewController.m

#import "CitiesViewController.h"
#import "City.h"
#import "Continent.h"
#import "CityDetailViewController.h"

@interface CitiesViewController ()

@property (strong, nonatomic) IBOutlet UIButton *firstButton;
@property (strong, nonatomic) IBOutlet UIButton *secondButton;

@end

@implementation CitiesViewController

- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    self.title = self.continent.name;
    [self.firstButton setTitle:[[self.continent.subLocations objectAtIndex:0] name] forState:UIControlStateNormal];
    [self.secondButton setTitle:[[self.continent.subLocations objectAtIndex:1] name] forState:UIControlStateNormal];
}

- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
    City *city = nil;
    if (sender==self.firstButton) {
        city = (City *)[self.continent.subLocations objectAtIndex:0];
    } else if (sender==self.secondButton) {
        city = (City *)[self.continent.subLocations objectAtIndex:1];
    }
    CityDetailViewController *cityDetailVC = segue.destinationViewController;
    cityDetailVC.city = city;
}

@end
\end{objclst}

\end{enumerate}

\end{lsgitem}


\begin{lsgitem}{tableviews}{Table Views}

\begin{enumerate}

\item Zunächst ziehen wir eine Table View aus der Object Library auf den Continents View Controller und ersetzen so dessen Content View. Mit gehaltener \keys{\ctrlkey}-Taste ziehen wir eine Verbindung von der Table View zum Continent View Controller und weisen diesen somit sowohl dem Datasource als auch dem Delegate Attribut zu.

Anschließend kann eine Prototype Cell erstellt werden, indem ein Table View Cell Objekt aus der Object Library auf die Table View gezogen wird. Diese wird im Attributes Inspector mit dem \emph{Basic} Stil konfiguriert. Dann wird mit gehaltener \keys{\ctrlkey}-Taste eine Push Segue Verbindung zum Cities View Controller gezogen.

Nun können wir die Methoden der Protokolle im Code implementieren und außerdem die anderen Methoden anpassen:

\subsubsection{ContinentsViewController.m}

\begin{objclst}
#import "ContinentsViewController.h"
#import "Continent.h"
#import "City.h"
#import "CitiesViewController.h"

@interface ContinentsViewController ()

@property (strong, nonatomic) NSArray *continents;

@end

@implementation ContinentsViewController

#pragma mark - User Interaction

- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
    
    NSIndexPath *indexPath = [self.tableView indexPathForCell:sender];
    Continent *continent = [self.continents objectAtIndex:indexPath.row];
    
    CitiesViewController *citiesViewController = segue.destinationViewController;
    citiesViewController.continent = continent;
}

#pragma mark - Table View Datasource

- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return 1;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return [self.continents count];
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    
    Continent *continent = [self.continents objectAtIndex:indexPath.row];
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"continentCell"];
    
    cell.textLabel.text = continent.name;
    cell.imageView.image = continent.image;
    
    return cell;
}

#pragma mark - Getters

- (NSArray *)continents {
    if (!_continents) {
        
        Continent *ozeanien = [[Continent alloc] init];
        ozeanien.name = @"Ozeanien";
        
        City *melbourne = [[City alloc] init];
        melbourne.name = @"Melbourne";
        melbourne.image = [UIImage imageNamed:@"melbourne"];
        City *sydney = [[City alloc] init];
        sydney.name = @"Sydney";
        sydney.image = [UIImage imageNamed:@"sydney"];
        City *brisbane = [[City alloc] init];
        brisbane.name = @"Brisbane";
        brisbane.image = [UIImage imageNamed:@"brisbane"];
        City *adelaide = [[City alloc] init];
        adelaide.name = @"Adelaide";
        adelaide.image = [UIImage imageNamed:@"adelaide"];
        City *perth = [[City alloc] init];
        perth.name = @"Perth";
        perth.image = [UIImage imageNamed:@"perth"];
        City *canberra = [[City alloc] init];
        canberra.name = @"Canberra";
        canberra.image = [UIImage imageNamed:@"canberra"];
        
        ozeanien.subLocations = @[melbourne, sydney, brisbane, adelaide, perth, canberra];

        Continent *nordamerika = [[Continent alloc] init];
        nordamerika.name = @"Nordamerika";
        
        City *losAngeles = [[City alloc] init];
        losAngeles.name = @"Los Angeles";
        losAngeles.image = [UIImage imageNamed:@"losAngeles"];
        City *sanFrancisco = [[City alloc] init];
        sanFrancisco.name = @"San Francisco";
        sanFrancisco.image = [UIImage imageNamed:@"sanFrancisco"];
        
        nordamerika.subLocations = @[sanFrancisco, losAngeles];

        _continents = @[ozeanien, nordamerika];
    }
    return _continents;
}

@end
\end{objclst}

\subsubsection{CitiesViewController.h}

\begin{objclst}
@class Continent;

@interface CitiesViewController : UITableViewController

@property (strong, nonatomic) Continent *continent;

@end
\end{objclst}

\subsubsection{CitiesViewController.m}

\begin{objclst}
#import "CitiesViewController.h"
#import "City.h"
#import "Continent.h"
#import "CityDetailViewController.h"

@interface CitiesViewController ()

@property (readonly, nonatomic) NSArray *cities;

@end

@implementation CitiesViewController

- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    self.title = self.continent.name;
}

#pragma mark - User Interaction

- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
    
    NSIndexPath *indexPath = [self.tableView indexPathForCell:sender];
    City *city = [self.cities objectAtIndex:indexPath.row];

    CityDetailViewController *cityDetailVC = segue.destinationViewController;
    cityDetailVC.city = city;
}

#pragma mark - Table View Datasource

- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return 1;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return [self.cities count];
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {

    City *city = [self.cities objectAtIndex:indexPath.row];
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cityCell"];

    cell.textLabel.text = city.name;
    cell.imageView.image = city.image;

    return cell;
}

#pragma mark - Getters

- (NSArray *)cities {
    return self.continent.subLocations;
}

@end
\end{objclst}

\end{enumerate}

\end{lsgitem}




\end{lsg}

\end{document}
